# 1 保存所有字段

执行更新 SQL 时， `Save` 将保存所有字段

```go
db.First(&user)  
  
user.Name = "jinzhu 2"  
user.Age = 100  
db.Save(&user)  
// UPDATE users SET name='jinzhu 2', age=100, birthday='2016-01-01', updated_at = '2013-11-17 21:34:10' WHERE id=111;
```

`Save` 是一个 upsert 函数：

- 如果值不包含主键，则执行 `Create`
- 如果值有主键，则首先执行 **Update** (所有字段，通过 `Select(*)` )。
- 如果**更新**后 `rows affected = 0` ，则它会自动恢复到 `Create` 。

> **注意** ： `Save` 保证会发生更新或插入
>
> 为了防止在没有行匹配时意外创建，请使用 `Select(*).Updates()`
> 
> `Save` 方法不能与 `Model` 方法一起使用。如果不是模型，则需要加上where条件否则会报错 `WHERE conditions required`

# 2 阻止全局更新

如果在没有任何条件的情况下执行批量更新，GORM 将不会运行它，并且默认会返回 `ErrMissingWhereClause` 错误。

必须使用一些条件或使用原始 SQL 或启用 `AllowGlobalUpdate` 模式，例如：

```go
db.Model(&User{}).Update("name", "jinzhu").Error // gorm.ErrMissingWhereClause

db.Model(&User{}).Where("1 = 1").Update("name", "jinzhu")
// UPDATE users SET `name` = "jinzhu" WHERE 1=1

db.Exec("UPDATE users SET name = ?", "jinzhu")
// UPDATE users SET name = "jinzhu"

db.Session(&gorm.Session{AllowGlobalUpdate: true}).Model(&User{}).Update("name", "jinzhu")
// UPDATE users SET `name` = "jinzhu"
```

# 3 更新单列

当使用 `Update` 更新单个列时，需要满足一些条件，否则会引发错误 `ErrMissingWhereClause`。

当使用 `Model` 方法并且其值具有主值时，主键将用于构建条件，例如：

```go
// Update with conditions  
db.Model(&User{}).Where("active = ?", true).Update("name", "hello")  
// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE active=true;  
  
// User's ID is `111`:  
db.Model(&user).Update("name", "hello")  
// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111;  
  
// Update with conditions and model value  
db.Model(&user).Where("active = ?", true).Update("name", "hello")  
// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111 AND active=true;
```
# 4 更新多列

`Updates` 支持使用 `struct` 或 `map[string]interface{}` 进行更新，使用 `struct` 更新时默认只更新非零字段

```go
// Update attributes with `struct`, will only update non-zero fields  
db.Model(&user).Updates(User{Name: "hello", Age: 18, Active: false})  
// UPDATE users SET name='hello', age=18, updated_at = '2013-11-17 21:34:10' WHERE id = 111;  
  
// Update attributes with `map`  
db.Model(&user).Updates(map[string]interface{}{"name": "hello", "age": 18, "active": false})  
// UPDATE users SET name='hello', age=18, active=false, updated_at='2013-11-17 21:34:10' WHERE id=111;
```

> **注意：** 使用结构体更新时，GORM 只会更新非零字段。你可能需要使用 `map` 来更新属性，或者使用 `Select` 来指定要更新的字段。
# 5 update hooks 

GORM 允许使用 hooks `BeforeSave` 、 `BeforeUpdate` 、 `AfterSave` 、 `AfterUpdate` 。这些方法会在更新记录时被调用
# 6 批量更新

如果我们没有使用 `Model` 指定具有主键值的记录，GORM 将执行批量更新

```go
// Update with struct
db.Model(User{}).Where("role = ?", "admin").Updates(User{Name: "hello", Age: 18})
// UPDATE users SET name='hello', age=18 WHERE role = 'admin';

// Update with map
db.Table("users").Where("id IN ?", []int{10, 11}).Updates(map[string]interface{}{"name": "hello", "age": 18})
// UPDATE users SET name='hello', age=18 WHERE id IN (10, 11);

```
# 7 使用SQL表达式更新

GORM 允许使用 SQL 表达式更新列，例如：

```go
// product's ID is `3`  
db.Model(&product).Update("price", gorm.Expr("price * ? + ?", 2, 100))  
// UPDATE "products" SET "price" = price * 2 + 100, "updated_at" = '2013-11-17 21:34:10' WHERE "id" = 3;  
  
db.Model(&product).Updates(map[string]interface{}{"price": gorm.Expr("price * ? + ?", 2, 100)})  
// UPDATE "products" SET "price" = price * 2 + 100, "updated_at" = '2013-11-17 21:34:10' WHERE "id" = 3;  
  
db.Model(&product).UpdateColumn("quantity", gorm.Expr("quantity - ?", 1))  
// UPDATE "products" SET "quantity" = quantity - 1 WHERE "id" = 3;  
  
db.Model(&product).Where("quantity > 1").UpdateColumn("quantity", gorm.Expr("quantity - ?", 1))  
// UPDATE "products" SET "quantity" = quantity - 1 WHERE "id" = 3 AND quantity > 1;
```

# 8 从子查询更新

使用 SubQuery 更新表

```go
db.Model(&user).Update("company_name", db.Model(&Company{}).Select("name").Where("companies.id = users.company_id"))
// UPDATE "users" SET "company_name" = (SELECT name FROM companies WHERE companies.id = users.company_id);

db.Table("users as u").Where("name = ?", "jinzhu").Update("company_name", db.Table("companies as c").Select("name").Where("c.id = u.company_id"))

db.Table("users as u").Where("name = ?", "jinzhu").Updates(map[string]interface{}{"company_name": db.Table("companies as c").Select("name").Where("c.id = u.company_id")})
```

# 9 不使用Hooks/时间跟踪

如果要跳过 `Hooks` 方法并且不跟踪更新时的更新时间，则可以使用 `UpdateColumn` 、 `UpdateColumns` ，其工作原理类似于 `Update` 、 `Updates`

```go
// Update single column  
db.Model(&user).UpdateColumn("name", "hello")  
// UPDATE users SET name='hello' WHERE id = 111;  
  
// Update multiple columns  
db.Model(&user).UpdateColumns(User{Name: "hello", Age: 18})  
// UPDATE users SET name='hello', age=18 WHERE id = 111;  
  
// Update selected columns  
db.Model(&user).Select("name", "age").UpdateColumns(User{Name: "hello", Age: 0})  
// UPDATE users SET name='hello', age=0 WHERE id = 111;
```
# 10 检查字段是否已改变

GORM 提供了 `Changed` 方法，可以在 **Before Update Hooks** 中使用，它将返回字段是否已更改。

`Changed` 方法仅适用于 `Update` 和 `Updates` 方法，并且仅检查 `Update` / `Updates` 的更新值是否等于模型值。如果已更改且未省略，则返回 true。

```go
func (u *User) BeforeUpdate(tx *gorm.DB) (err error) {
  // if Role changed
  if tx.Statement.Changed("Role") {
    return errors.New("role not allowed to change")
  }

  if tx.Statement.Changed("Name", "Admin") { // if Name or Role changed
    tx.Statement.SetColumn("Age", 18)
  }

  // if any fields changed
  if tx.Statement.Changed() {
    tx.Statement.SetColumn("RefreshedAt", time.Now())
  }
  return nil
}

db.Model(&User{ID: 1, Name: "jinzhu"}).Updates(map[string]interface{"name": "jinzhu2"})
// Changed("Name") => true
db.Model(&User{ID: 1, Name: "jinzhu"}).Updates(map[string]interface{"name": "jinzhu"})
// Changed("Name") => false, `Name` not changed
db.Model(&User{ID: 1, Name: "jinzhu"}).Select("Admin").Updates(map[string]interface{
  "name": "jinzhu2", "admin": false,
})
// Changed("Name") => false, `Name` not selected to update

db.Model(&User{ID: 1, Name: "jinzhu"}).Updates(User{Name: "jinzhu2"})
// Changed("Name") => true
db.Model(&User{ID: 1, Name: "jinzhu"}).Updates(User{Name: "jinzhu"})
// Changed("Name") => false, `Name` not changed
db.Model(&User{ID: 1, Name: "jinzhu"}).Select("Admin").Updates(User{Name: "jinzhu2"})
// Changed("Name") => false, `Name` not selected to update
```
# 11 更改更新值

要更改 Before Hooks 中的更新值，应该使用 `SetColumn` ，除非它是使用 `Save` 进行的完整更新，例如：

```go
func (user *User) BeforeSave(tx *gorm.DB) (err error) {
  if pw, err := bcrypt.GenerateFromPassword(user.Password, 0); err == nil {
    tx.Statement.SetColumn("EncryptedPassword", pw)
  }

  if tx.Statement.Changed("Code") {
    user.Age += 20
    tx.Statement.SetColumn("Age", user.Age)
  }
}

db.Model(&user).Update("Name", "jinzhu")
```

|**操作​**​|​**​更新方式​**​|​**​钩子内修改字段的方法​**​|
|---|---|---|
|`Save`|更新所有字段|直接修改模型字段|
|`Updates`|只更新变化字段|必须使用 `SetColumn`|

## 11.1 底层原理

- GORM 在执行更新前会​**​缓存变更字段​**​
    
- 在 `BeforeUpdate`钩子触发时，变更集已经确定
    
- 直接修改模型字段不会更新变更集（`Updates`模式）
    
- `SetColumn`会直接修改最终生成的 SQL
