# 创建

##  `(*DB)Create(value interface{}) (tx *DB)`

- `Create`方法用于向数据库插入​**​单条或多条​**​记录，并将插入数据的主键值回填到传入的结构体中。

- **注意事项**：必须传递指针，否则无法回填主键

```go
user := User{Name: "Jinzhu", Age: 18, Birthday: time.Now()}

result := db.Create(&user) // 通过数据的指针来创建

user.ID             // 返回插入数据的主键
result.Error        // 返回 error
result.RowsAffected // 返回插入记录的条数
```

还可以传入一个切片创建多项纪录

```go
users := []*User{
    {Name: "Jinzhu", Age: 18, Birthday: time.Now()},
    {Name: "Jackson", Age: 19, Birthday: time.Now()},
}

result := db.Create(users) // pass a slice to insert multiple row

result.Error        // returns error
result.RowsAffected // returns inserted records count
```
## `(*DB)CreateInBatches(value interface{}, batchSize int) (tx *DB)`

-  v1.20.7+ 新增方法，用于​**​大批量数据的分批插入​**​，避免单条SQL过长导致的性能问题。

```go
// 准备1000条记录
var users []User
for i := 0; i < 1000; i++ {
    users = append(users, User{Name: fmt.Sprintf("user%d", i)})
}

// 每批插入100条
result := db.CreateInBatches(users, 100)

fmt.Println("总插入行数:", result.RowsAffected)
if result.Error != nil {
    // 处理错误（可能部分批次成功）
}
```
# 用指定的字段创建记录

## `Select(query interface{}, args ...interface{}) (tx *DB)`

- `Select`方法用于​**​显式指定要操作的字段​**​，可以在查询、创建和更新操作中限制字段范围。默认情况下 GORM 会操作所有字段。

- ​**​字段名格式​**​：

    - 可以使用结构体字段名（如 `Name`）
    
    - 也可以使用数据库列名（如 `name`）
    
    - ​**​推荐使用结构体字段名​**​（更符合 Go 习惯）

```go
db.Select("Name", "Age", "CreatedAt").Create(&user)  
// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES ("jinzhu", 18, "2020-07-04 11:05:21.775")
```

## `Omit(columns ...string) (tx *DB)`

- `Omit`方法用于​**​排除特定字段​**​，在查询、创建和更新操作中跳过指定字段。
- 在同一链式调用中，如果同时使用`Select`和`Omit`，只会采用 `Select`.

```go
db.Omit("Name", "Age", "CreatedAt").Create(&user)  
// INSERT INTO `users` (`birthday`,`updated_at`) VALUES ("2020-01-01 00:00:00.000", "2020-07-04 11:05:21.775")
```
# 创建钩子

GORM允许用户通过实现这些接口 `BeforeSave`, `BeforeCreate`, `AfterSave`, `AfterCreate`来自定义钩子。 这些钩子方法会在创建一条记录时被调用，关于钩子的生命周期请参阅[Hook](../配置/Hook.md)。

```go
func (u *User) BeforeCreate(tx *gorm.DB) (err error) {
  u.UUID = uuid.New()

    if u.Role == "admin" {
        return errors.New("invalid role")
    }
    return
}
```

如果你想跳过`Hooks`方法，可以使用`SkipHooks`会话模式，例子如下

```go
DB.Session(&gorm.Session{SkipHooks: true}).Create(&user)

DB.Session(&gorm.Session{SkipHooks: true}).Create(&users)

DB.Session(&gorm.Session{SkipHooks: true}).CreateInBatches(users, 100)

```
# 根据Map创建

GORM支持通过 `map[string]interface{}` 与 `[]map[string]interface{}{}`来创建记录。

```go
db.Model(&User{}).Create(map[string]interface{}{
  "Name": "jinzhu", "Age": 18,
})

// batch insert from `[]map[string]interface{}{}`
db.Model(&User{}).Create([]map[string]interface{}{
  {"Name": "jinzhu_1", "Age": 18},
  {"Name": "jinzhu_2", "Age": 20},
})
```

> **注意**当使用map来创建时，钩子方法不会执行，关联不会被保存且不会回写主键。
# 关联创建

创建关联数据时，如果关联值非零，这些关联会被upsert，并且它们的`Hooks`方法也会被调用。

```go
type CreditCard struct {
  gorm.Model
  Number   string
  UserID   uint
}

type User struct {
  gorm.Model
  Name       string
  CreditCard CreditCard
}

db.Create(&User{
  Name: "jinzhu",
  CreditCard: CreditCard{Number: "411111111111"},
})
// INSERT INTO `users` ...
// INSERT INTO `credit_cards` ...
```

你可以通过`Select`, `Omit`方法来跳过关联更新，示例如下：

```go
db.Omit("CreditCard").Create(&user)

// skip all associations
db.Omit(clause.Associations).Create(&user)

```
# 默认值

你可以通过结构体Tag `default`来定义字段的默认值，示例如下：

```go
type User struct {
  ID   int64
  Name string `gorm:"default:galeone"`
  Age  int64  `gorm:"default:18"`
}
```

> **注意**，如果字段被设置了默认值，当结构体的字段值是零值的时候比如 `0`, `''`, `false`，这些字段值将不会被保存到数据库中，你可以使用指针类型或者Scanner/Valuer来避免这种情况。


>**注意**，若要让字段在数据库中拥有默认值则必须使用`default`Tag来为结构体字段设置默认值。如果想要在数据库迁移的时候跳过默认值，可以使用 `default:(-)`，示例如下：