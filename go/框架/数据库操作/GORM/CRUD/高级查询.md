# 1 智能选择字段

在GORM中，你可以针对特定字段使用 `Select method`。这在处理大型模型但只需要部分字段时尤其有用，尤其是在 API 响应中。

```go
type User struct {
  ID     uint
  Name   string
  Age    int
  Gender string
  // hundreds of fields
}

type APIUser struct {
  ID   uint
  Name string
}

// GORM will automatically select `id`, `name` fields when querying
db.Model(&User{}).Limit(10).Find(&APIUser{})
// SQL: SELECT `id`, `name` FROM `users` LIMIT 10
```

QueryFields 模式是 GORM 中一个​**​解决多表字段冲突​**​的高级特性，特别针对复杂 JOIN 查询中的字段歧义问题设计。

```go
db, err := gorm.Open(sqlite.Open("gorm.db"), &gorm.Config{
  QueryFields: true,
})

// Default behavior with QueryFields set to true
db.Find(&user)
// SQL: SELECT `users`.`name`, `users`.`age`, ... FROM `users`

// Using Session Mode with QueryFields
db.Session(&gorm.Session{QueryFields: true}).Find(&user)
// SQL: SELECT `users`.`name`, `users`.`age`, ... FROM `users`

```
# 2 Locking

`clause.Locking`是 GORM 中控制数据库锁机制的核心配置，用于实现悲观锁并发控制。

```go
type Locking struct {
    Strength string // 锁强度
    Table    Table  // 锁定目标表
    Options string  // 锁选项
}
```
### 2.1.1 `Strength`- 锁强度控制

|​**​可选值​**​|​**​等效 SQL​**​|​**​锁类型​**​|​**​适用场景​**​|
|---|---|---|---|
|`"UPDATE"`|`FOR UPDATE`|排他锁 (X锁)|更新前锁定，防止其他事务修改|
|`"SHARE"`|`LOCK IN SHARE MODE`|共享锁 (S锁)|读取时允许共享锁，阻止排他锁|
|`""`(空)|无锁|-|默认不添加锁|
```go
// 排他锁 (常用)
db.Clauses(clause.Locking{Strength: "UPDATE"})

// 共享锁
db.Clauses(clause.Locking{Strength: "SHARE"})
```
### 2.1.2 `Options`- 锁行为选项

|​**​可选值​**​|​**​数据库支持​**​|​**​行为描述​**​|​**​超时处理​**​|
|---|---|---|---|
|`"NOWAIT"`|PostgreSQL, MySQL 8+, Oracle|立即返回错误，不等待锁释放|`ErrLockWaitTimeout`|
|`"SKIP LOCKED"`|PostgreSQL, MySQL 8+, Oracle|跳过被锁定的行|静默跳过|
|`""`(空)|所有数据库|默认等待锁释放|可能永久阻塞|

```go
// 不等待锁
db.Clauses(clause.Locking{Strength: "UPDATE", Options: "NOWAIT"})

// 跳过锁定行
db.Clauses(clause.Locking{Strength: "UPDATE", Options: "SKIP LOCKED"})
```
### 2.1.3 `Table`- 锁目标表

|​**​配置方式​**​|​**​说明​**​|​**​SQL 示例​**​|
|---|---|---|
|`clause.CurrentTable`|锁定主表 (默认)|`SELECT ... FOR UPDATE`|
|`clause.Table{Name: "orders"}`|锁定指定表|`SELECT ... FOR UPDATE OF orders`|
|`clause.Table{Name: "alias"}`|锁定表别名|`SELECT ... FOR UPDATE OF alias`|
# 3 子查询

子查询是 SQL 中一个强大的功能，允许嵌套查询。当使用 \*gorm.DB 对象作为参数时，GORM 可以自动生成子查询。

```go
// Simple subquery
db.Where("amount > (?)", db.Table("orders").Select("AVG(amount)")).Find(&orders)
// SQL: SELECT * FROM "orders" WHERE amount > (SELECT AVG(amount) FROM "orders");

// Nested subquery
subQuery := db.Select("AVG(age)").Where("name LIKE ?", "name%").Table("users")
db.Select("AVG(age) as avgage").Group("name").Having("AVG(age) > (?)", subQuery).Find(&results)
// SQL: SELECT AVG(age) as avgage FROM `users` GROUP BY `name` HAVING AVG(age) > (SELECT AVG(age) FROM `users` WHERE name LIKE "name%")

```
## 3.1 从子查询中查询

GORM 允许在 FROM 子句中使用子查询，从而实现复杂的查询和数据组织。

```go
// Using subquery in FROM clause
db.Table("(?) as u", db.Model(&User{}).Select("name", "age")).Where("age = ?", 18).Find(&User{})
// SQL: SELECT * FROM (SELECT `name`,`age` FROM `users`) as u WHERE `age` = 18

// Combining multiple subqueries in FROM clause
subQuery1 := db.Model(&User{}).Select("name")
subQuery2 := db.Model(&Pet{}).Select("name")
db.Table("(?) as u, (?) as p", subQuery1, subQuery2).Find(&User{})
// SQL: SELECT * FROM (SELECT `name` FROM `users`) as u, (SELECT `name` FROM `pets`) as p
```
# 4 多列IN

GORM 支持具有多列的 IN 子句，允许在单个查询中根据多个字段值过滤数据。

```go
// Using IN with multiple columns
db.Where("(name, age, role) IN ?", [][]interface{}{{"jinzhu", 18, "admin"}, {"jinzhu2", 19, "user"}}).Find(&users)
// SQL: SELECT * FROM users WHERE (name, age, role) IN (("jinzhu", 18, "admin"), ("jinzhu 2", 19, "user"));
```
# 5 FirstOrInit/Attrs/Assign

这三个方法组合使用可以实现强大的"查找或初始化"模式，特别适合需要灵活处理对象状态的场景。

| **方法​**​      | ​**​功能​**​ | ​**​执行时机​**​ | ​**​数据库影响​**​ |
| ------------- | ---------- | ------------ | ------------- |
| `FirstOrInit` | 查找记录或初始化对象 | 立即执行查询       | 不修改数据库        |
| `Attrs`       | 设置初始化属性    | 仅当记录不存在时应用   | 不修改数据库        |
| `Assign`      | 设置强制属性     | 无论记录是否存在都应用  | 不修改数据库        |
## 5.1 `FirstOrInit(dest interface{}, conds ...interface{}) (tx *DB)`

- 查找匹配的第一条记录，如果不存在则​**​初始化​**​目标结构体（不保存到数据库）

```go
var user User
// 查找 name="jinzhu" 的用户，不存在则初始化
db.Where(User{Name: "jinzhu"}).FirstOrInit(&user)

// 结果：
// - 存在：user = 数据库记录
// - 不存在：user = User{Name: "jinzhu"}
```

**特点​**​：

- 纯内存操作，不产生 SQL 写操作
    
- 初始化对象可用于后续处理（如展示默认表单）
    
- 常与 `Attrs`和 `Assign`链式组合
## 5.2 `Attrs(attrs ...interface{}) (tx *DB)`

- 设置​**​仅当记录不存在时​**​应用的属性

```go
var user User
db.Where(User{Name: "non_exist"}).
   Attrs(User{Age: 30}). // 仅当不存在时设置
   FirstOrInit(&user)

// 结果：
// - 记录存在：忽略 Age
// - 记录不存在：user = User{Name: "non_exist", Age: 30}
```
**特点​**​：

- 相当于"默认值"提供者
    
- 支持结构体和 map 参数
    
- 不影响已存在记录的初始化
## 5.3 `Assign(attrs ...interface{}) (tx *DB)`

- 设置​**​无论记录是否存在​**​都应用的属性

```go
var user User
db.Where(User{Name: "jinzhu"}).
   Assign(User{Age: 20}). // 总是设置
   FirstOrInit(&user)

// 结果：
// - 记录存在：user = 数据库记录 + Age=20
// - 记录不存在：user = User{Name: "jinzhu", Age: 20}
```

**特点​**​：

- 强制覆盖属性值
    
- 常用于统计字段更新
    
- 支持链式调用多次赋值
## 5.4 FirstOrCreate

- 用于获取符合给定条件的第一条记录，如果未找到匹配记录则创建新记录。
- 可以和 `attrs` 配合使用，这些属性用于创建记录，但不用于初始搜索查询。
- 可以和 `assign` 配合使用， `Assign` 方法都会设置记录的属性，并将这些属性保存回数据库。
# 6 优化器/索引提示

GORM 支持优化器和索引提示，允许影响查询优化器的执行计划。这在优化查询性能或处理复杂查询时特别有用。

优化器提示是一些指令，用于指示数据库的查询优化器应如何执行查询。GORM 通过 gorm.io/hints 包方便地使用优化器提示。

```go
import "gorm.io/hints"

// Using an optimizer hint to set a maximum execution time
db.Clauses(hints.New("MAX_EXECUTION_TIME(10000)")).Find(&User{})
// SQL: SELECT * /*+ MAX_EXECUTION_TIME(10000) */ FROM `users`

```

| **提示函数​**​                  | ​**​适用数据库​**​ | ​**​功能描述​**​ | ​**​SQL 等效​**​                                            |
| --------------------------- | ------------- | ------------ | --------------------------------------------------------- |
| `UseIndex(hint string)`     | MySQL         | 建议使用指定索引     | `USE INDEX (index_name)`                                  |
| `ForceIndex(hint string)`   | MySQL         | 强制使用指定索引     | `FORCE INDEX (index_name)`                                |
| `IgnoreIndex(hint string)`  | MySQL         | 忽略指定索引       | `IGNORE INDEX (index_name)`                               |
| `UseHashJoin()`             | PostgreSQL    | 建议使用哈希连接     | `/*+ HashJoin(t1 t2) */`                                  |
| `UseMergeJoin()`            | PostgreSQL    | 建议使用合并连接     | `/*+ MergeJoin(t1 t2) */`                                 |
| `UseNestedLoop()`           | PostgreSQL    | 建议使用嵌套循环连接   | `/*+ NestLoop(t1 t2) */`                                  |
| `WithIndex(index string)`   | SQL Server    | 强制使用索引       | `WITH (INDEX(index_name))`                                |
| `NoLock()`                  | SQL Server    | 使用 NOLOCK 提示 | `WITH (NOLOCK)`                                           |
| `StraightJoin()`            | MySQL         | 强制按书写顺序连接表   | `STRAIGHT_JOIN`                                           |
| `SetVar(key, value string)` | MySQL 8.0+    | 设置会话变量       | `SET_VAR(optimizer_switch='condition_fanout_filter=off')` |
# 7 批量查询

使用 `FindInBatches` ，GORM 可以按指定的批次大小处理记录。在批处理函数内部，可以对每一批记录应用操作。

```go
// Processing records in batches of 100
result := db.Where("processed = ?", false).FindInBatches(&results, 100, func(tx *gorm.DB, batch int) error {
  for _, result := range results {
    // Operations on each record in the batch
  }

  // Save changes to the records in the current batch
  tx.Save(&results)

  // tx.RowsAffected provides the count of records in the current batch
  // The variable 'batch' indicates the current batch number

  // Returning an error will stop further batch processing
  return nil
})

// result.Error contains any errors encountered during batch processing
// result.RowsAffected provides the count of all processed records across batches
```


`FindInBatches` 是一种有效的工具，可以以可管理的块形式处理大量数据，优化资源使用和性能。
# 8 Pluck

GORM 中的 `Pluck` 方法用于从数据库中查询单个列，并将结果扫描到切片中。当需要从模型中检索特定字段时，此方法非常理想。

```go
// Retrieving ages of all users
var ages []int64
db.Model(&User{}).Pluck("age", &ages)

// Retrieving names of all users
var names []string
db.Model(&User{}).Pluck("name", &names)

// Retrieving names from a different table
db.Table("deleted_users").Pluck("name", &names)

// Using Distinct with Pluck
db.Model(&User{}).Distinct().Pluck("Name", &names)
// SQL: SELECT DISTINCT `name` FROM `users`
```
# 9 Scopes

Scopes 是 GORM 中​**​构建模块化、可复用查询条件​**​的核心机制，它通过将查询逻辑封装为独立函数，实现优雅的链式组合。

```go
type ScopeFunc func(*gorm.DB) *gorm.DB
```

```go
// 活跃用户过滤
func ActiveUsers(db *gorm.DB) *gorm.DB {
    return db.Where("active = ?", true)
}

// 时间范围过滤
func CreatedBetween(start, end time.Time) ScopeFunc {
    return func(db *gorm.DB) *gorm.DB {
        return db.Where("created_at BETWEEN ? AND ?", start, end)
    }
}

// 分页控制
func Paginate(page, size int) ScopeFunc {
    return func(db *gorm.DB) *gorm.DB {
        offset := (page - 1) * size
        return db.Offset(offset).Limit(size)
    }
}


// 基础用法
db.Scopes(ActiveUsers).Find(&users)

// 多Scope组合
db.Scopes(
    ActiveUsers,
    CreatedBetween(lastWeek, now),
    Paginate(1, 20),
).Find(&users)
```
# 10 获取匹配的记录数

可以使用 `Count` 来确定查询中满足特定条件的记录数。

```go
var count int64  
  
// Counting users with specific names  
db.Model(&User{}).Where("name = ?", "jinzhu").Or("name = ?", "jinzhu 2").Count(&count)  
// SQL: SELECT count(1) FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2'  
  
// Counting users with a single name condition  
db.Model(&User{}).Where("name = ?", "jinzhu").Count(&count)  
// SQL: SELECT count(1) FROM users WHERE name = 'jinzhu'  
  
// Counting records in a different table  
db.Table("deleted_users").Count(&count)  
// SQL: SELECT count(1) FROM deleted_users


// Counting distinct names  
db.Model(&User{}).Distinct("name").Count(&count)  
// SQL: SELECT COUNT(DISTINCT(`name`)) FROM `users`  
  
// Counting distinct values with a custom select  
db.Table("deleted_users").Select("count(distinct(name))").Count(&count)  
// SQL: SELECT count(distinct(name)) FROM deleted_users  
  
// Counting grouped records  
users := []User{  
  {Name: "name1"},  
  {Name: "name2"},  
  {Name: "name3"},  
  {Name: "name3"},  
}  
  
db.Model(&User{}).Group("name").Count(&count)  
// Count after grouping by name  
// count => 3
```

