# 客户端

MCP 客户端连接到服务器以访问工具、资源和提示。MCP-Go 为所有支持的传输方式提供客户端实现，使您能够轻松地将 MCP 功能集成到应用程序中。

客户端分为以下几类：

> STDIO Client &#x20;

**Best for：**

* 命令行应用程序
* 桌面软件集成
* 本地开发和测试
* 单服务器连接

```go
// Create STDIO client
client, err := client.NewStdioMCPClient("server-command", "arg1", "arg2")
```

> StreamableHTTP Client

**Best for:** &#x20;

* Web 应用程序
* 微服务架构
* 负载均衡部署
* 类似 REST 的交互

```go
// Create StreamableHTTP client
client := client.NewStreamableHttpClient("http://localhost:8080/mcp")

func createStreamableHTTPClient() client.Client {
    // Basic StreamableHTTP client
	httpTransport, err := transport.NewStreamableHTTP(server.URL,
		// Set timeout
		transport.WithHTTPTimeout(30*time.Second),
		// Set custom headers
		transport.WithHTTPHeaders(map[string]string{
			"X-Custom-Header": "custom-value",
			"Y-Another-Header": "another-value",
		}),
		// With custom HTTP client
		transport.WithHTTPBasicClient(&http.Client{}),
	)
    if err != nil {
        log.Fatalf("Failed to create StreamableHTTP transport: %v", err)
    }
    c := client.NewClient(httpTransport)
    return c
}
```

## 客户端生命周期

客户端的生命周期大致可以分为：

1. **Creation** - Instantiate the client\
   创建 - 实例化客户端
2. **Initialization** - Establish connection and exchange capabilities\
   初始化 - 建立连接并交换能力
3. **Operation** - Use tools, resources, and prompts\
   操作 - 使用工具、资源和提示
4. **Cleanup** - Close connections and free resources\
   清理 - 关闭连接并释放资源

```go
func demonstrateClientLifecycle() error {
    // 1. Creation
    c, err := client.NewSSEMCPClient("server-command")
    if err != nil {
        return fmt.Errorf("client creation failed: %w", err)
    }
 
    // Ensure cleanup happens
    defer func() {
        if closeErr := c.Close(); closeErr != nil {
            log.Printf("Error closing client: %v", closeErr)
        }
    }()
 
    ctx := context.Background()
 
    // 2. Initialization
    if err := c.Initialize(ctx); err != nil {
        return fmt.Errorf("client initialization failed: %w", err)
    }
 
    // 3. Operation
    if err := performClientOperations(ctx, c); err != nil {
        return fmt.Errorf("client operations failed: %w", err)
    }
 
    // 4. Cleanup (handled by defer)
    return nil
}
 
func performClientOperations(ctx context.Context, c client.Client) error {
    // List available tools
    tools, err := c.ListTools(ctx)
    if err != nil {
        return err
    }
 
    log.Printf("Found %d tools", len(tools.Tools))
 
    // Use the tools
    for _, tool := range tools.Tools {
        result, err := c.CallTool(ctx, mcp.CallToolRequest{
            Params: mcp.CallToolRequestParams{
                Name:      tool.Name,
                Arguments: map[string]interface{}{
                    "input": "example input",
                    "format": "json",
                },
            },
        })
        if err != nil {
            log.Printf("Tool %s failed: %v", tool.Name, err)
            continue
        }
 
        log.Printf("Tool %s result: %+v", tool.Name, result)
    }
 
    return nil
}
```

初始化建立MCP连接并交换功能：

```go
// 使用自定义参数
func initializeClientWithDetails(ctx context.Context, c client.Client) error {
    // Initialize with custom client info
    initReq := mcp.InitializeRequest{
        Params: mcp.InitializeRequestParams{
            ProtocolVersion: "2024-11-05",
            Capabilities: mcp.ClientCapabilities{
				Roots: (*struct {
					ListChanged bool `json:"listChanged,omitempty"`
				})(&struct {
					ListChanged bool
				}{ListChanged: true}),
			},  // 开启服务端变更自动通知
            ClientInfo: mcp.ClientInfo{
                Name:    "My Application",
                Version: "1.0.0",
            },
        },
    }
 
    result, err := c.InitializeWithRequest(ctx, initReq)
    if err != nil {
        return fmt.Errorf("initialization failed: %w", err)
    }
 
    log.Printf("Connected to server: %s v%s", 
        result.ServerInfo.Name, 
        result.ServerInfo.Version)
    
    log.Printf("Server capabilities: %+v", result.Capabilities)
 
    return nil
}
```

## 优雅关闭

```go
type ManagedClient struct {
    client client.Client
    ctx    context.Context
    cancel context.CancelFunc
    done   chan struct{}
}
 
func NewManagedClient(clientType, address string) (*ManagedClient, error) {
    var c client.Client
    var err error
 
    switch clientType {
    case "stdio":
        c, err = client.NewSSEMCPClient("server-command")
    case "streamablehttp":
        c = client.NewStreamableHttpClient(address)
    case "sse":
        c = client.NewSSEMCPClient(address)
    default:
        return nil, fmt.Errorf("unknown client type: %s", clientType)
    }
 
    if err != nil {
        return nil, err
    }
 
    ctx, cancel := context.WithCancel(context.Background())
 
    mc := &ManagedClient{
        client: c,
        ctx:    ctx,
        cancel: cancel,
        done:   make(chan struct{}),
    }
 
    // Initialize in background
    go func() {
        defer close(mc.done)
        if err := c.Initialize(ctx); err != nil {
            log.Printf("Client initialization failed: %v", err)
        }
    }()
 
    return mc, nil
}
 
func (mc *ManagedClient) WaitForReady(timeout time.Duration) error {
    select {
    case <-mc.done:
        return nil
    case <-time.After(timeout):
        return fmt.Errorf("client initialization timeout")
    case <-mc.ctx.Done():
        return mc.ctx.Err()
    }
}
 
func (mc *ManagedClient) Close() error {
    mc.cancel()
    
    // Wait for initialization to complete or timeout
    select {
    case <-mc.done:
    case <-time.After(5 * time.Second):
        log.Println("Timeout waiting for client shutdown")
    }
 
    return mc.client.Close()
}
```
