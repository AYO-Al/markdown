Go中的所有测试文件以`_test`结尾，并且与测试目标函数在同一个包下。
- 单元测试：测试用例以TestTagetFuncName命名，参数为`t testing.T`
- 基准测试：测试用例以BenchmarkTargetFuncName命名，参数为`b *testing.B`
- 网络测试：

# 基准测试

基准测试（benchmark）是 go testing 库提供的，用来度量程序性能，算法优劣的利器。

基准测试报告每一列值对应的含义如下：

```go
type BenchmarkResult struct {  
    N         int           // 迭代次数  
    T         time.Duration // 基准测试花费的时间  
    Bytes     int64         // 一次迭代处理的字节数  
    MemAllocs uint64        // 总的分配内存的次数  
    MemBytes  uint64        // 总的分配内存的字节数  
}
```

```go
// 编写被测函数
// main.go
package main

func Fib(n int) int {
	if n < 2 {
		return n
	}
	return Fib(n-1) + Fib(n-2)
}

func main() {

}

// 编写测试用例
// main_test.go
package main  
  
import "testing"  
  
func BenchmarkFib10(b *testing.B) {  
    for n := 0; n < b.N; n++ {  
       Fib(10)  
    }  
}  
  
func BenchmarkFib20(b *testing.B) {  
    for n := 0; n < b.N; n++ {  
       Fib(20)  
    }  
}
```

- `go test [packages]` 指定测试范围

|方法一|方法二|
|---|---|---|
|运行当前 package 内的用例|go test packageName|go test .|
|运行子 package 内的用例|go test packageName/subName|go test ./subName|
|递归运行所有的用例|go test packageName/...|go test ./...|

- `go test` 命令默认不执行 benchmark 测试，需要加上 `-bench` 参数，该参数支持正则表达式，只有匹配到的测试用例才会执行，使用 `.` 则运行所有测试用例
```go
# go test -bench=".*Fib.*" .
goos: darwin
goarch: arm64
pkg: test1
cpu: Apple M3 Pro
BenchmarkFib10-12        6945440               148.6 ns/op
BenchmarkFib20-12          65966             18432 ns/op
PASS
ok      test1   2.776s

```
- BenchmarkFib10-12：即 `GOMAXPROCS`，默认等于 CPU 核数
-  `6945440 148.6 ns/op`：表示在单位时间内（默认是1s）被测函数运行了6945440，每次运行耗时148.6 ns。
- `ok      test1   2.776s`：表示本次测试总耗时。
## 参数

| 参数                 | 说明                   |
| ------------------ | -------------------- |
| -benchtime t\[\|x] | 指定测试至少使用时间或测试用例运行总次数 |
| -count n           | 指定测试总                |
| -cpu n             | 指定测试用例使用的CPU核心数      |
| -benchmem          | 测试用例显示内存属性           |
| -race              | 报告测试用例中的数据竞争问题       |
```go
# go test -bench=".*Fib.*" -benchtime=1000x  .
goos: darwin
goarch: arm64
pkg: test1
cpu: Apple M3 Pro
BenchmarkFib10-12           1000               390.7 ns/op
BenchmarkFib20-12           1000             34976 ns/op
PASS
ok      test1   0.207s


# go test -bench=".*Fib.*" -count=3  .        
goos: darwin
goarch: arm64
pkg: test1
cpu: Apple M3 Pro
BenchmarkFib10-12        7158513               149.1 ns/op
BenchmarkFib10-12        8126667               149.6 ns/op
BenchmarkFib10-12        8212851               147.6 ns/op
BenchmarkFib20-12          66843             18019 ns/op
BenchmarkFib20-12          66022             18513 ns/op
BenchmarkFib20-12          64130             18534 ns/op
PASS
ok      test1   8.309s

// 这里看到使用6个核心性能就不会再上升了
#  go test -bench=".*Fib.*" -cpu=1,2,4,6,8  .
goos: darwin
goarch: arm64
pkg: test1
cpu: Apple M3 Pro
BenchmarkFib10           7026470               155.9 ns/op
BenchmarkFib10-2         7953574               147.6 ns/op
BenchmarkFib10-4         7234066               147.4 ns/op
BenchmarkFib10-6         8240185               147.2 ns/op
BenchmarkFib10-8         7673361               146.9 ns/op
BenchmarkFib20             65749             18297 ns/op
BenchmarkFib20-2           65668             18423 ns/op
BenchmarkFib20-4           65403             18649 ns/op
BenchmarkFib20-6           65172             19101 ns/op
BenchmarkFib20-8           63703             18575 ns/op
PASS
ok      test1   13.644s

// 每次分配0个字节的内存，分配0次
# go test -bench=".*Fib.*" -benchmem  .
goos: darwin
goarch: arm64
pkg: test1
cpu: Apple M3 Pro
BenchmarkFib10-12        7144215               151.7 ns/op             0 B/op          0 allocs/op
BenchmarkFib20-12          65829             18396 ns/op               0 B/op          0 allocs/op
PASS
ok      test1   2.819s

```
## 其他函数

如果在编写测试用例时，需要一些前期准备工作，这个时候就可以使用下面三个函数来将这部分耗时去掉。

- b.ResetTimer()：重置计时器，忽略前面的准备时间
- b.StopTimer()/b.StartTimer()：暂停计时和开始计时
## 并发性能

在基准测试中，可以使用`RunParallel`来测试并发性能

```go
package main  
  
import "testing"  
  
func BenchmarkFib20(b *testing.B) {  
    for n := 0; n < b.N; n++ {  
       Fib(20)  
    }  
}  
  
func BenchmarkFibParallel20(b *testing.B) {  
    b.SetParallelism(4)  // 设置并行度
    b.RunParallel(func(pb *testing.PB) {  
       for pb.Next() {  // pb.Next控制循环次数到b.N次
          Fib(20)  
       }  
    })  
}

/*
goos: darwin
goarch: arm64
pkg: test1
cpu: Apple M3 Pro
BenchmarkFib20-6                   57039             18897 ns/op
BenchmarkFibParallel20-6          348778              3397 ns/op
PASS
ok      test1   2.963s

*/
```

这里可以看到设置在4个goroutine中运行比1个的时候快了6倍左右。

调用了 b.RunParallel 方法的测试函数将会在单独的 goroutine 中启动。 需要注意的是，b.StartTimer、b.StopTime、b.ResetTimer 三个方法会影响到所有 goroutine，因此不要在并行测试中调用。

并行基准测试其并发度受环境变量 GOMAXPROCS 控制，默认情况下是 CPU 核心数。 可以在测试开始前，通过 b.SetParallelism 方法实现对并发度的控制，例如执行b.SetParallelism(2) 则意味着并发度为 2*GOMAXPROCS。