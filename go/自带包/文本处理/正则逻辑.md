# 正则引擎是如何思考的

**匹配过程**：正则匹配的过程就像是一辆只能前进和后退（回溯）的汽车，在字符串这条路上行驶，根据规则（正则）进行匹配。

理解引擎如何工作，是写出高效正则的关键。其核心是​**​回溯机制​**​。

1. **​贪婪模式（Greedy） - 默认行为​**​
    
    - ∙​**​原则​**​：量词（`*`, `+`, `?`, `{m,n}`）会​**​匹配尽可能多的字符​**​。
    - ∙​**​过程​**​：先“吃掉”所有能匹配的字符，然后为了满足后续的模式，再​**​一点点“吐出来”（回溯）​**​，直到后续模式也能匹配成功。
    - ∙​**​示例​**​：正则 `a.*b` 匹配字符串 `"axxyb"`
        
        - ∙`a` 匹配第一个 `a` ✅
        - ∙`.*` ​**​贪婪地匹配所有字符​**​：`a` -> `ax` -> `axx` -> `axxy` -> `axxyb` ✅（但此时 `.*` 也“吃掉”了 `b`）
        - ∙引擎发现模式后面还有个 `b`，但字符串末尾已无字符。于是开始​**​回溯​**​。
        - ∙`.*` 吐出最后一个字符 `b`，尝试用模式中的 `b` 去匹配它，成功！ ✅
        - ∙​**​最终匹配​**​：`axxyb`
        
    
2. ​**​懒惰模式（Lazy/Reluctant） - 量词后加 `?`​**​
    
    - ∙​**​原则​**​：量词会​**​匹配尽可能少的字符​**​。
    - ∙​**​过程​**​：先匹配最少必需的字符，如果后续模式失败，再​**​多“吃”一个字符​**​，直到整体匹配成功。
    - ∙​**​示例​**​：正则 `a.*?b` 匹配字符串 `"axxyb"`
        
        - ∙`a` 匹配第一个 `a` ✅
        - ∙`.*?` ​**​懒惰地匹配最少的字符（0个）​**​，剩下 `"xxyb"`。
        - ∙尝试用 `b` 匹配剩下的第一个字符 `x`，失败 ❌。
        - ∙`.*?` 被迫多匹配一个字符 `x`，剩下 `"xyb"`。
        - ∙尝试用 `b` 匹配 `x`，失败 ❌。
        - ∙`.*?` 再匹配一个 `x`，剩下 `"yb"`。
        - ∙尝试用 `b` 匹配 `y`，失败 ❌。
        - ∙`.*?` 再匹配一个 `y`，剩下 `"b"`。
        - ∙尝试用 `b` 匹配 `b`，成功！ ✅
        - ∙​**​最终匹配​**​：`axxyb` （结果和贪婪模式一样，但过程更耗时）
        
    
3. ​**​独占模式（Possessive） - 量词后加 `+`（部分引擎支持，如Java）​**​
    
    - ∙​**​原则​**​：类似贪婪模式，但​**​一旦匹配就绝不回溯​**​。
    - ∙​**​过程​**​：匹配尽可能多的字符，然后​**​锁死​**​，不允许回溯。如果后续模式不匹配，则整体直接失败。
    - ∙​**​示例​**​：正则 `a.*+b` 匹配字符串 `"axxyb"`
        
        - ∙`a` 匹配第一个 `a` ✅
        - ∙`.*+` ​**​贪婪且独占地匹配所有字符​**​：`a` -> `ax` -> ... -> `axxyb` ✅
        - ∙引擎发现模式后面还有个 `b`，但字符串已无剩余字符。
        - ∙因为 `.*+` 是独占的，拒绝回溯。
        - ∙​**​整体匹配失败​**​ ❌

**注意：正则中有部分元素是不消耗字符的。注意使用下列元素时锚点的使用**

|类型|语法|名称|作用|示例|
|---|---|---|---|---|
|​**​锚点​**​|`^`|起始锚点|匹配字符串的​**​开始位置​**​|`^abc` 匹配以 "abc" 开头的字符串|
||`$`|结束锚点|匹配字符串的​**​结束位置​**​|`xyz$` 匹配以 "xyz" 结尾的字符串|
||`\b`|单词边界|匹配单词的​**​开始或结束位置​**​（\w和\W之间）|`\bword\b` 匹配独立的单词 "word"|
||`\B`|非单词边界|匹配​**​不是​**​单词边界的位置|`\Bword\B` 匹配 "swordfish" 中的 "word"|
|​**​前瞻断言​**​|`(?=...)`|正向先行断言|匹配​**​后面​**​是...的位置|`X(?=YZ)` 匹配后面是 "YZ" 的 "X"|
||`(?!...)`|负向先行断言|匹配​**​后面不是​**​...的位置|`X(?!YZ)` 匹配后面不是 "YZ" 的 "X"|
|​**​后顾断言​**​|`(?<=...)`|正向后行断言|匹配​**​前面​**​是...的位置|`(?<=AB)X` 匹配前面是 "AB" 的 "X"|
||`(?<!...)`|负向后行断言|匹配​**​前面不是​**​...的位置|`(?<!AB)X` 匹配前面不是 "AB" 的 "X"|