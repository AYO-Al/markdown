在 Go 语言中使用 `sync.Mutex` 进行加锁操作时，​**​锁的作用范围是基于锁实例本身，而不是针对特定函数​**​。

# 1 核心概念：锁保护的是数据，而不是代码

# 2 锁作用于互斥量实例


```go
var mu sync.Mutex // 这是一个锁实例  
func A() {     
    mu.Lock()     
    defer mu.Unlock()     
    // 临界区代码 
    }  
func B() {     
    mu.Lock()     
    defer mu.Unlock()     
    // 另一个临界区代码 
}
```

在这个例子中：

- 当 `A()` 持有了 `mu` 的锁时
- 所有试图在 `B()`、`A()` 或其他函数中锁定同一个 `mu` 的 goroutine 都会被阻塞
- 无论这些函数在哪里被调用

**锁保护的是代码执行路径，而不是变量本身​**​。

```go
var a sync.Mutex  
var b sync.Mutex  
var wg sync.WaitGroup  
var s = 1  
  
func A() {  
    a.Lock()  
    defer a.Unlock()  
    defer wg.Done()  
    s++  
    time.Sleep(1 * time.Second)  
}  
  
func B() {  
    b.Lock()  
    defer b.Unlock()  
    defer wg.Done()  
    s++  
    time.Sleep(1 * time.Second)  
}  
  
func main() {  
    wg.Add(2)  
    go A()  
    go B()  
    wg.Wait()  
    fmt.Println(s)  
}
```

# 3 锁使用的基本原则

1. ​**​一对一原则​**​：每个共享资源应该有自己专用的锁
    
```go
// 错误：多个资源共用同一个锁
var lockForEverything sync.Mutex

// 正确：每个资源独立锁定
var (
    lockForUsers sync.Mutex
    lockForOrders sync.Mutex
)
```
    
2. ​**​最小化原则​**​：锁住的范围应尽量小
    
```go
// 错误：长时间操作锁住资源
func process() {
    lock.Lock()
    // 长时间计算...
    // 网络请求...
    lock.Unlock()
}

// 正确：只锁关键操作
func process() {
    // 不锁计算操作...
    result = heavyCalculation()
    
    lock.Lock()
    sharedResource = result // 只锁赋值操作
    lock.Unlock()
}
```
    
3. ​**​层级原则​**​：如果多个资源有关联，用更高层锁保护
    
```go
type Account struct {
    mu sync.Mutex
    balance int
}

type Bank struct {
    mu sync.Mutex
    accounts map[int]*Account
}

func (b *Bank) Transfer(from, to int, amount int) {
    b.mu.Lock() // 顶级锁保护账户映射
    defer b.mu.Unlock()
    
    fromAcc := b.accounts[from]
    toAcc := b.accounts[to]
    
    fromAcc.mu.Lock()
    defer fromAcc.mu.Unlock()
    toAcc.mu.Lock()
    defer toAcc.mu.Unlock()
    
    fromAcc.balance -= amount
    toAcc.balance += amount
}
```