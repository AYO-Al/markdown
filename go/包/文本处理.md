# strings包

## 字符串比较

```go
package main  
  
import (  
    "fmt"  
    "strings")  
  
func main() {  
    a := "a"  
    b := "A"  
    /*
    Compare 函数，用于比较两个字符串的大小，如果两个字符串相等，返回为 0。如果 a 小于 b ，返回 -1 ，反之返回 1 。不推荐使用这个函数，直接使用 == != > < >= <= 等一系列运算符更加直观。
    */
    fmt.Println(strings.Compare(a, b))  // 区分大小  
    fmt.Println(strings.EqualFold(a, b)) // 不区分大小  
}

/*
1
true
*/
```
## 是否存在某个字符

有好几个函数可以进行判断。
```go
// 子串 substr 在 s 中，返回 true
func Contains(s, substr string) bool

// chars 中任何一个 Unicode 代码点在 s 中，返回 true
func ContainsAny(s, chars string) bool

// Unicode 代码点 r 在 s 中，返回 true
func ContainsRune(s string, r rune) bool

// 返回子字符串在字符串中第一次出现的位置，不存在则返回 -1。
func Index(s, substr string) int 

// IndexAny 返回 s 中字符的任何 Unicode 代码点的第一个实例的索引，如果 s 中不存在字符的 Unicode 代码点，则返回 -1。
func IndexAny(s, chars string) int

// 返回rune中在s中的位置，否则返回-1
func IndexRune(s string, r rune) int

// 带Last前缀的函数返回最后一次出现的位置
```

看下运行这些函数返回的结果。
```go
func main() {
	s := "yes"
	fmt.Println(strings.Contains(s, "ye"))
	fmt.Println(strings.ContainsAny(s, "y e"))
	fmt.Println(strings.ContainsRune(s, 'y'))
	fmt.Println(strings.Index(s, "ye"))
	fmt.Println(strings.IndexAny(s, "ye"))
	fmt.Println(strings.IndexRune(s, 'e'))
}

/*
true
true
true
0
0
1
*/
```

其实查看前面三个函数的源代码就会发现其实调用的都是相对应类型`Index`函数。
```go
  
// Contains reports whether substr is within s.
func Contains(s, substr string) bool {
	return Index(s, substr) >= 0
}

// ContainsAny reports whether any Unicode code points in chars are within s.
func ContainsAny(s, chars string) bool {
	return IndexAny(s, chars) >= 0
}

// ContainsRune reports whether the Unicode code point r is within s.
func ContainsRune(s string, r rune) bool {
	return IndexRune(s, r) >= 0
}
```
## 子串出现的次数

go中计算子串在字符串中出现次数的函数是`Count`。
```go

func main() {
	s := "chesesese"
	fmt.Println(strings.Count(s, "ese")) // 2
}
```

特别要注意的是Count返回的是在字符串中无重叠的次数，所以这里返回的是2.当substr为空的时候返回的是`utf8.RuneCountInString(s) + 1`
## 字符串分割

字符串分割最常用的就是`Split`系列函数。
```go
func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }
func SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) }
func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }
func SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep, len(sep), n) }
```

可以看到这四个函数都调用了`genSplit`函数。

这四个函数都是通过 sep 进行分割，返回\[\]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 `Split("abc","")`，得到的是\[a b c\]。

Split(s, sep) 和 SplitN(s, sep, -1) 等价；SplitAfter(s, sep) 和 SplitAfterN(s, sep, -1) 等价。带`After`的函数会把分隔符保留下来。

带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n < 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n > 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割，比如：
```go
func main() {  
    s := "I,love,you,as,who,you,are"  
    fmt.Println(strings.Split(s, ","))  
    fmt.Println(strings.SplitN(s, ",", 2))  
    fmt.Println(strings.SplitAfter(s, ","))  
    fmt.Println(strings.SplitAfterN(s, ",", 2))  
}

/*
[I love you as who you are]
[I love,you,as,who,you,are]
[I, love, you, as, who, you, are]
[I, love,you,as,who,you,are]
*/
```
## 判断字符串前缀或后缀

```go
// s 中是否以 prefix 开始
func HasPrefix(s, prefix string) bool {
  return len(s) >= len(prefix) && s[0:len(prefix)] == prefix
}
// s 中是否以 suffix 结尾
func HasSuffix(s, suffix string) bool {
  return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
}
```

如果 prefix 或 suffix 为 "" , 返回值总是 true。
## Join操作

可以将字符串切片跳过sep分隔符连接起来。
```go
func Join(a []string, sep string) string
```
## 构建重复字符

函数签名如下：

```
func Repeat(s string, count int) string
```

将 s 重复 count 次，如果 count 为负数或返回值长度 len(s)*count 超出 string 上限会导致 panic，这个函数使用很简单：

```
fmt.Println("ba" + strings.Repeat("na", 2))
```

输出结果：

```
banana
```
## 字符替换

可以使用`Map`或`Replace`对字符进行替换，但这两个方法粒度不同。
```go
func Map(mapping func(rune) rune, s string) string

// 如果 n < 0，则不限制替换次数，即全部替换
func Replace(s, old, new string, n int) string
// 该函数内部直接调用了函数 Replace(s, old, new , -1)
func ReplaceAll(s, old, new string) string
```

`Map`方法可以设置一个函数按照字面量粒度对字符进行映射替换。如果 mapping 返回值 <0 ，则舍弃该字符。该方法只能对每一个字符做处理，但处理方式很灵活，可以方便的过滤，筛选汉字等。
```go
var mapping = func(r rune) rune {  
    switch {  
    case r >= 'A' && r <= 'Z':  
       return r + 32  
    case r >= 'a' && r <= 'z':  
       return r  
    }  
    return -1  
}  
  
func main() {  
    s := "yeyeyeyeeyAAAAAA"  
    fmt.Println(strings.Map(mapping, s))   // yeyeyeyeeyaaaaaa
}
```

`Replace`函数可以直接替换字符串中的子串。
```go
func main() {  
    s := "yeyeyeyeeyAAAAAA"  
    fmt.Println(strings.Replace(s, "A", "T", -1))  // yeyeyeyeeyTTTTTT
}
```

`Replce`方法只能对单个子串进行替换，如果想进行多子串替换，可以定义一个`Replacer`对象。
```go

func main() {
	// NewReplacer panics if given an odd number of arguments.
	r := strings.NewReplacer("y", "Y", "s", "S") // 参数为一个old->new映射列表
	fmt.Println(r.Replace("ysysy"))
	b := &bytes.Buffer{}
	r.WriteString(b, "ysysysysys") // 替换后的字符写入io.Writer
	fmt.Println(b)
}
/*
YSYSY
YSYSYSYSYS
*/
```

## 大小写转换

在strings包中提供了四种大小写转换的函数。
```go
func ToLower(s string) string
func ToLowerSpecial(c unicode.SpecialCase, s string) string
func ToUpper(s string) string
func ToUpperSpecial(c unicode.SpecialCase, s string) string
```

这四种函数都用来把字符串全部转换成大小或小写。但`ToLowerSpecial`和`ToUpperSpecial`可以转换特殊字符的大小写。
```go
func main() {
    // 自定义大小写映射规则
    specialCase := unicode.SpecialCase{
        unicode.CaseRange{
            Lo: 0x41, // 'A'
            Hi: 0x5A, // 'Z'
            Delta: [unicode.MaxCase]rune{32, 0, 0}, // 将大写字母转换为小写
        },
        unicode.CaseRange{
            Lo: 0x61, // 'a'
            Hi: 0x7A, // 'z'
            Delta: [unicode.MaxCase]rune{-32, 0, 0}, // 将小写字母转换为大写
        },
    }

    fmt.Println(strings.ToLowerSpecial(specialCase, "HELLO, WORLD")) // "hello, world"
    fmt.Println(strings.ToLowerSpecial(specialCase, "hello, world")) // "HELLO, WORLD"
}
```
## 修剪字符串

```go
// 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉
func Trim(s string, cutset string) string
// 将 s 左侧的匹配 cutset 中的任一字符的字符去掉
func TrimLeft(s string, cutset string) string
// 将 s 右侧的匹配 cutset 中的任一字符的字符去掉
func TrimRight(s string, cutset string) string
// 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。
func TrimPrefix(s, prefix string) string
// 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。
func TrimSuffix(s, suffix string) string
// 将 s 左侧和右侧的间隔符去掉。常见间隔符包括：'\t', '\n', '\v', '\f', '\r', ' ', U+0085 (NEL)
func TrimSpace(s string) string
// 将 s 左侧和右侧的匹配 f 的字符去掉
func TrimFunc(s string, f func(rune) bool) string
// 将 s 左侧的匹配 f 的字符去掉
func TrimLeftFunc(s string, f func(rune) bool) string
// 将 s 右侧的匹配 f 的字符去掉
func TrimRightFunc(s string, f func(rune) bool) string
```

示例：
```go
x := "!!!@@@你好,!@#$ Gophers###$$$"
fmt.Println(strings.Trim(x, "@#$!%^&*()_+=-"))
fmt.Println(strings.TrimLeft(x, "@#$!%^&*()_+=-"))
fmt.Println(strings.TrimRight(x, "@#$!%^&*()_+=-"))
fmt.Println(strings.TrimSpace(" \t\n Hello, Gophers \n\t\r\n"))
fmt.Println(strings.TrimPrefix(x, "!"))
fmt.Println(strings.TrimSuffix(x, "$"))

f := func(r rune) bool {
    return !unicode.Is(unicode.Han, r) // 非汉字返回 true
}
fmt.Println(strings.TrimFunc(x, f))
fmt.Println(strings.TrimLeftFunc(x, f))
fmt.Println(strings.TrimRightFunc(x, f))

/*
你好,!@#$ Gophers
你好,!@#$ Gophers###$$$
!!!@@@你好,!@#$ Gophers
Hello, Gophers
!!@@@你好,!@#$ Gophers###$$$
!!!@@@你好,!@#$ Gophers###$$
你好
你好,!@#$ Gophers###$$$
!!!@@@你好
*/
```
## Builder 类型

该类型实现了 io 包下的 Writer, ByteWriter, StringWriter 等接口，可以向该对象内写入数据，Builder 没有实现 Reader 等接口，所以该类型不可读，但提供了 String 方法可以获取对象内的数据。
```go
// 该方法向 b 写入一个字节
func (b *Builder) WriteByte(c byte) error
// WriteRune 方法向 b 写入一个字符
func (b *Builder) WriteRune(r rune) (int, error)
// WriteRune 方法向 b 写入字节数组 p
func (b *Builder) Write(p []byte) (int, error)
// WriteRune 方法向 b 写入字符串 s
func (b *Builder) WriteString(s string) (int, error)
// Len 方法返回 b 的数据长度。
func (b *Builder) Len() int
// Cap 方法返回 b 的 cap。
func (b *Builder) Cap() int
// Grow 方法将 b 的 cap 至少增加 n (可能会更多)。如果 n 为负数，会导致 panic。
func (b *Builder) Grow(n int)
// Reset 方法将 b 清空 b 的所有内容。
func (b *Builder) Reset()
// String 方法将 b 的数据以 string 类型返回。
func (b *Builder) String() string
```

Builder 的 cap 会自动增长，一般不需要手动调用 Grow 方法。

String 方法可以方便的获取 Builder 的内容。可以用来拼接字符串。
```go
b := strings.Builder{}
_ = b.WriteByte('7')
n, _ := b.WriteRune('夕')
fmt.Println(n)
n, _ = b.Write([]byte("Hello, World"))
fmt.Println(n)
n, _ = b.WriteString("你好，世界")
fmt.Println(n)
fmt.Println(b.Len())
fmt.Println(b.Cap())
b.Grow(100)
fmt.Println(b.Len())
fmt.Println(b.Cap())
fmt.Println(b.String())
b.Reset()
fmt.Println(b.String())

/*
3
12
15
31
32
31
164
7夕Hello, World你好，世界
*/
```
## 字符串切片

在Go中字符串的底层其实就是一个\[\]byte，所以也可以使用切片的方法获取子串。
```go
/*
s[start:end(exclusive)]
*/

func main() {  
    s := "abcdefgh"  
    fmt.Println(s[:4])   //省略代表从头开始
}
```

# 字符串拼接方法汇总