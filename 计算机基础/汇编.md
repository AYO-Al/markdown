[toc]
### 1、基础知识

> 在计算机中，通常用数字后面跟一个英文字母来表示该进制的数字
>
> 十进制用D，二进制用B，八进制用O，十六进制用H
>
> 比如：115D，1010B，0754O，0075H

#### 1#、计算机运行汇编程序的步骤

1. 用编辑程序建立ASM源文件
2. 用MASM程序(汇编程序)把ASM文件转换成OBJ文件
   - 汇编程序：把源文件转换为二进制代码表示的目标文件。转换的过程中汇编程序会对源程序进行扫视，如果有语法错误会指出。还可以展开宏指令
   - 可以用编辑程序更改错误
3. 用LINK程序把OBJ文件转换成EXE文件
   - 连接程序把目标文件和库文件或其他目标文件连接在一起形成可执行文件
4. 用DOS命令直接键入文件名就可以执行该程序

#### 1.1、进制转换

##### 1.1.1、十进制转其他进制

```汇编
# 整数部分
十进制转其他进制：用十进制数除以进制，直到商为零，反向取余结束
例如：9D->1001B
9/2=4...1
4/2=2...0
2/2=1...0
1/2=0...1 
#商为零结束，反向取余，所以转二进制为1001B

# 小数部分
十进制转其他进制：乘进制取整，顺序输出
例如：0.68D->精度5的二进制
0.68*2=1.36->1
0.36*2=0.72->0
0.72*2=1.44->1
0.44*2=0.88->0
0.88*2=1.76->1
# 达到题目要求精度，把取出来的整数部分顺序输出即可
# 0.68D->0.10101B
```

##### 1.1.2、其他进制转十进制

```汇编
# 其他进制转十进制：数位数乘以位权，位权从零开始
# 小数也一样，小数从-1开始
例如：1011B：1*2^0+1*2^1+0*2^2+1*2^3=1+2+0+8=11D
例如：101O：1*8^0+0*8^1+1*8^2=17D
例如：0.11B->1*2^-1+1*2^-2=0.75D
```

##### 1.1.3、其他进制转换

```
# 二进制转八进制：三合一，三位二进制数合起来为一位八进制数
# 二进制转十六进制：四合一
# 整数不足向前补零，小数不足向后补零
例如：1011B:011->3 001(不足向前补零)->1 
# 所以1011B->13O

# 其他进制转二进制就反过来
```

#### 1.2、数据的表示

>计算机存储信息的最小单位称为位，在绝大多数系统中只能表示0和1两种转态
>
>计算机系统采用二进制表示数值数据
>
>也采用二进制编码表示非数值数据和指令

##### 1.2.1、数的补码表示

> 把一个数连同符号在机器中的表示加以数值化，这样的数称为机器数
>
> 一般用最高有效位来表示数的符号。正数用0表示，负数用1表示
>
> 机器数可以采用不同的码制来表示，常用的又原码，补码和反码表示法

```汇编
# 补码表示正数采用符号-绝对值表示:即数的最高有效位为0表示符号为正，数的其余部分则表示数的绝对值
假设机器字长为8，则：[+1]_补=00000001

# 补码表示负数时采用2^n-|x|表示，n为机器的字长
如：[-1]_补=2^8-1=11111111

# 补码还有一种相对简单的求方法：先写出与该负数相对于的正数的补码表示，然后将其按位取反，最后在末位加1，这种方法称为求补运算
例如：写出-117D的补码
+117D表示为	0000 0000 0111 0101
按位求反后	   1111 1111 1000 1010
末位加1		1111 1111 1000 1011
用十六进制表示    F   F     8    B
# 所以[-117]_补：0FF8BH

所以可以证明补码表示的数具有以下特性：
[x]_补-求补>[-x]_补-求补>[x]
```

##### 1.2.2、补码的加减法

- 补码的加法规则：[x+y]_补=[x]_补+[y]_补
- 补码的减法规则：[x-y]_补=[x]_补+[-y]_补

#### 1.3、基本数据类型

1. 字节：一个字节由8个二进制位组成

2. 字：两个字节组成一个字，低8位称为低字节，高8位称为高字节

3. 双字：低16位称为底字，高16位称为高字

4. 四字：四个字组成，能表示的精度更高

5. 十字节：10个字节组成

6. 字符串：汇编语言的组字符串是由字符构成的一个线性数组。通常每个字符用一个字节表示，但有时每个字符也可以用一个字或一个双字来表示

   

### 2、80x86

- 80x86寄存器组

| 寄存器名         | 寄存器分类 | 作用                                                         |
| ---------------- | ---------- | ------------------------------------------------------------ |
| AH\|AL  AX       | 数据寄存器 | 作为累加器用，所以它是算术运算的主要寄存器。在乘，除等指令中指定用来存放操作数。另外，所有的I/O指令都是要这一寄存器与外部设备传送信息 |
| BH\|BL  BX       | 数据寄存器 | 作为通用寄存器使用。此外在计算机存储器地址时，它经常用来作为基址寄存器 |
| CH\|CL  CX       | 数据寄存器 | 可以作为通用寄存器使用。此外常用来保存计数值，如在移位指令，循环指令和串处理指令中用作隐含的计数器 |
| DH\|DL  DX       | 数据寄存器 | 可以用作通用寄存器。一般在作双字长运算时把DX和AX组合在一起存放一个双字长数，DX用来存放高位字。此外，对某些I/O操作，DX可用来存放I/O的端口地址 |
| SP  堆栈指针     | 指针寄存器 | 可以用来指示段顶的偏移地址，BP可作为堆栈区中的一个基地址一边访问堆栈中的信息 |
| BP  基址指针     | 指针寄存器 | 可以与ss联用来确定堆栈段中的某一存储单元的地址               |
| SI  源地址       | 变址寄存器 | SI和DI一般用来与DS联用，用来确定数据段中某一存储单元的地址。这两个变址寄存器都具有自动增量和自动减量的功能，所以用作变址是很方便的 |
| DI  目的地址     | 变址寄存器 | 在串处理指令中，SI和DI作为隐含的源变址和目的变址寄存器，此时SI和DS联用，DI和ES联用，分别达到在数据段和附加段中寻址的目的 |
| IP  指令指针     | 控制寄存器 | 用来存放代码段中的偏移地址。在程序运行的过程中，它始终指向下一条指令的首地址，它与CS联用确定下一条指令的物理地址 |
| FLAG  标志寄存器 | 控制寄存器 | 存放条件码标志，控制标志和系统标志的寄存器                   |
| CS  代码段       | 段寄存器   | 段寄存器专门用来存储器寻址，用来直接或间接的存放段地址       |
| DS  数据段       | 段寄存器   |                                                              |
| SS  堆栈段       | 段寄存器   |                                                              |
| ES  附加段       | 段寄存器   |                                                              |

- 通用寄存器
  - 数据寄存器，指针寄存器和变址寄存器统称为通用寄存器，这些寄存器除了格自专门用途外，它们均可用于传送和暂存数据，可以保存算术逻辑运算中的操作数和运算结果
- 数据寄存器
  - 主要用来保存操作数或运算结果等信息，它们的存在节省了为存取操作数所需占用总线和访问存储器的时间
- 变址和指针寄存器
  - 主要用于存放某个存储单元地址的偏移，或某组存储单元开始地址的偏移，即作为存储器指针使用。作为通用寄存器，它们也可以保存16位算术逻辑运算符中的操作数和运算结果，有事运算结果就是需要的存储单元地址的偏移
- 专用寄存器
  - IP，SP，FLAGS，段寄存器

- 标志寄存器FLAGS
  - 条件码标志
    - ==当有运算结果时产生==
    - 条件码标志用来记录程序中运行结果的状态信息，是根据有关指令的运行结果由cpu自动设置的。
    - OF:溢出标志。在运算过程中，如操作数超出了机器能表示的范围称为溢出。此时OF位置1，否则置0
    - SF:符号标志。记录运算结果的符号，结果为负时为1，否则置0
    - ZF:运算结果为0时，ZF位置1.否则置0
    - CF:进位标志。记录运算时从最高有效位产生的进位值。例如，执行加法指令时，最高有效位有进位时置1，否则置0
    - AF:辅助进位标志。记录运算时第三位产生的进位值。例如：执行加法指令第三位有进位时置1，否则置0
    - PF:奇偶标志。用来为机器中传送信息时可能产生的代码出错情况提供检验条件。当最低结果有效位中1的个数为偶数时置1，否则置0
  - 控制标志位
    - DF:方向标志。在串处理指令中控制处理信息的方向用。当DF为1时，每次操作后使变址寄存器SI和Di减小，这样就使得串处理从高地址向低地址方向处理。
  - 系统标志位
    - 可用于I/O，可屏蔽中断，程序调试，任务切换和系统工作方式等的控制
    - TF:陷阱标志。用于调试时的单步方法操作。当TF位为1时，每条指令执行完后产生陷阱，由系统控制计算机。当为0时CUP正常工作，不产生陷阱
    - IF:中断标志。当IF位为1时允许CPU响应可屏蔽中断请求，否则，关闭中断
    - IOPL：I/o特权级。在保护模式下，用于控制对I/O地址空间的访问

### 3、存储器

> 计算机存储信息的基本的单位是一个二进制位，一位可存储一个二进制数
>
> 在存储器里以字节为单位存储信息。每一个字节单元给以一个唯一的存储器地址，称为物理地址。地址从零开始，顺序的每次加一
>
> 地址也是用二进制数来表示的。它是无符号整数。书写格式为十六进制数
>
> 一个存储单元存放的信息称为该存储单元的内容
>
> 可表示为：(0004)=78H
>
> 一个字传入存储器要占用相继两个字节，存放时低位字节存入低地址，高位字节存入高地址，字单元的地址采用它的低地址来表示

### 4、寄存器寻址

#### 4.1、实模式下的寻址方式

> 在1mb的存储器里，每一个存储器单元都有一个唯一的20位地址，称为该存储单元的物理地址
>
> CPU访问存储器时，必须先确定所要访问所要访问的存储单元的物理地址才能操作该单元的内容
>
> 20位物理地址由16位段地址和16位偏移地址组成
>
> 存储单元的逻辑地址由：段值和偏移两部分组成
>
> 逻辑地址表示：段值：偏移
>
> 段地址是指每一段的起始地址(又称段基地址)
>
> 偏移地址是指在段内相对于段起始地址的偏移值
>
> 物理地址计算：把段地址左移4位再加上偏移地址值就形成物理地址。或写成：
>
> 16d*段地址+偏移地址=物理地址

#### 4.2、段寄存器

- 每个段寄存器可以确定一个段的起始地址
- 代码段CS
  - 用来存放当前正在运行的程序
- 数据段DS
  - 存放当前运行程序所需要的数据
  - 如果程序使用了串处理指令，则其源操作数也存放在数据段中
- 堆栈段
  - 定义了堆栈的所在区域，堆栈是一种数据结构，它开辟了一个比较特殊的存储区
- 附加段
  - 是附加的数据段，它是一个辅助的数据区，也是串处理指令的目的操作数存放区

| 段   | 偏移                 |
| ---- | -------------------- |
| cs   | IP                   |
| SS   | SP或BP               |
| DS   | BX,DI,SI或一个16位数 |
| ES   | DI(用于串指令)       |

#### 4.3、80x86的寻址方式

> 计算机是通过执行指令序列来解决的问题的
>
> 因而每种计算机都有一组指令集提供和用户使用
>
> 这组指令集就称为计算机的指令系统
>
> 计算机中的指令由==操作码字段==和==操作数字段==两部分组成
>
> 操作数字段可以有一个、两个、三个。通常称为一地址，二地址，三地址
>
> 当操作数有两个时，分别称为源操作数和目的操作数
>
> 当指令执行后将运算结果存放到目的操作数的地址之中
>
> 汇编语言是一种符号语言，它用助记符来表示操作码，用符号或符号地址来表示操作数或操作数地址。它与机器指令一一对应
>
> 寻址方式：表示指令中用于说明操作数所在地址的方法

##### 4.3.1、立即寻址方式

> 操作数直接存放在指令中，紧跟在操作码之后，它作为指令的一部分存放在代码段中，这种操作数称为立即数。
>
> 立即数可以是8位的也可以是16位的
>
> ==立即寻址方式用来表示常数，它经常用来给寄存器赋初值，并且只能用于源操作数字段，不能用于目的操作数字段==

```汇编
MOV AX,1234H
结果为：(AX)=1234H
# 立即数为8位的只能传给8位的寄存器，16位的只能传给16位的寄存器
```

##### 4.3.2、寄存器寻址

> 操作数在寄存器中，指令指定寄存器号
>
> 对于16位操作数，寄存器可以是：
>
> ==AX,BX,CX,DX,SI,DI,SP,BP等==
>
> 对于8位操作数，寄存器可以是：
>
> ==AL,AH,BL,BH,CL,CH,DL,DH==
>
> 这种寻址方式由于操作数就在寄存器中
>
> ==不需要访问存储器来取得操作数，因而可以取得较高的运算数度==

```汇编
MOV AX,BX
如指令执行前(AX)=3064H,(BX)=1234H,则执行指令后：
(AX)=1234H,(BX)保持不变
```

##### 4.3.3、有效地址

> 除以上两种寻址方式外，以下各种寻址方式的操作数都在除代码段以外的存储区中，通过不同寻址方式求得操作数地址，从而取得操作数
>
> 在80x86中，把操作数的偏移地址称为有效地址(EA)
>
> 有效地址的组成：
>
> 1. 位移量：是存放在指令中的一个8位、16位、32位的数，但它不是立即数，而是一个地址
> 2. 基址：存放在基址寄存器中的内容。是有效地址的基址部分，通常用来指向数据段中数组或字符串的首地址
> 3. 变址：是存放在变址寄存器中的内容。通常用来访问数组中的某个元素或字符串的某个字符
> 4. 比例因子：是386及后继机型新增的寻址方式的一个术语。其值可为1,2,4,8.在寻址中，可用变址寄存器的内容乘以比例因子来取的变址值
>
> 有效地址：EA=基址+(变址*比例因子)+位移量
>
> 80x86只能用16位寻址
>
> 位移量：0,8,16位
>
> 基址寄存器：BX,BP
>
> 变址寄存器：SI,DI
>
> 比例因子：无
>
> 在某些情况下，80x86允许程序员用段跨越前缀来改变系统所指认的默认段
>
> 但在以下情况下，不允许使用段跨越前缀：
>
> 1. 串处理指令的目的串必须用ES段
> 2. PUSH指令的目的和POP指令的源必须用SS段
> 3. 指令必须存放在CS段中

- 默认段选择规则

| 访问类型 | 所用段及寄存器         | 缺省选择规则                                               |
| -------- | ---------------------- | ---------------------------------------------------------- |
| 指令     | 代码段    cs寄存器     | 用于取址                                                   |
| 堆栈     | 堆栈段    ss寄存器     | 所有的堆栈的进栈和出栈，任何用ESP或EBP作为基址寄存器的访存 |
| 局部数据 | 数据段    DS寄存器     | 除相对于堆栈以及串处理指令的目的串以外的所有数据访问       |
| 目的串   | 附加数据段    ES寄存器 | 串处理指令的目的串                                         |

##### 4.3.4、直接寻址方式

> 操作数的有效地址只包含位移量一中成分，其值就存放在断码段中指令的操作码之后。位移量的值即操作数的有效地址
>
> 通过有效地址求物理地址获得内容
>
> ==80x86中为了使指令字节不要太长，规定双操作数指令的两个操作数中，只能有一个使用存储器寻址方式，这也是一个变量常常先要送到寄存器的原因==
>
> ==直接寻址方式通常用于处理单个存储器变量的情况。它可以实现在64K字节的段内寻找操作数。直接寻址的操作数通常是程序使用的变量==

- 例如：MOV AX,[8085H]

  - 执行后(AX)=3035H

  ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE8c27d7e0f8ddaaf26c77965c61ed90d4/309)

- 在汇编语言指令当中，可以用符号地址代替数值地址
  - MOV AX,VALUE或者MOV AX,[VALUE]
  - 如VALUE在附加段中，则应指定段超越前缀如下：
    - MOV AX,ES:VALUE或MOV AX,ES:[VALUE]

##### 4.3.5、寄存器间接寻址

> 操作数在存储器中，操作数有效地址在SI,DI,BX,BP在四个寄存器之一中。
>
> 在一般情况下，如果有效地址在SI,DI,BX中，则以DS段寄存器之内容为段值
>
> 有效地址在BP中时，则以SS段寄存器之内容为段值
>
> ==这种寻址方式可以用于表格处理，执行完一条指令后，只需修改寄存器内容就可以取得表格的下一项==

- 例如：MOV AX,[SI],如果(DS)=5000H,(SI)=1234H

  ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE59ab4ac68632fb9b9a52125e045ed8a4/312)

- 指令中也可以指定段超越前缀来取得其他段中的数据
  - MOV AX,ES:[BX]

##### 4.3.6、寄存器相对寻址

> 操作数的有效地址为基址寄存器(BX,BP)或变址寄存器(SI,DI)的内容和指令中指定的8位或16位位移量之和
>
> EA=（(BX),(BP),(SI)(DI)）+(8位位移量或16位位移量)
>
> 一般情况下若果SI,DI,BX的内容作为有效地址的一部分，那么段寄存器为DS
>
> 如果BP的内容为有效地址的一部分，那么引用的段寄存器是SS
>
> 在指令中给定的8位或16位位移量采用补码形式表示
>
> ==这种寻址方式同样可以处理表格，表格的首地址可设置为位移量，利用修改基址或变址寄存器的内容来取得表格的值==

- 例如：MOV AX,COUNT[DI]或MOV AX,[DI+COUNT]

  <img src="https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEf6192c3de390cdfeaf13f78f77c6c2c8/314" style="zoom:50%;" />



##### 4.3.7、基址变址寻址方式

> 操作数的有效地址是一个基址寄存器和一个变址寄存器的内容之和
>
> EA=((BX),(BP))+((SI),(DI))
>
> 段值情况与前面相同
>
> ==用于数组或表格处理，首地址可放于基址寄存器中，而使用变址寄存器来访问数组的各个元素。由于两个寄存器都可以修改，所以它比直接变址方式更加灵活==

- 例如：MOV AX,[BX] [DI]或MOV AX,[BX+DI]

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE41addc8f05c0cc0c0602d006c9e87b68/316)



##### 4.3.8、相对基址变址寻址

> 操作数的有效地址是一个基址寄存器与一个变址寄存器的内容和指令中指定的位移量之和
>
> EA=((BS),(BP))+((SI),(DI))+(8位位移量或16位位移量)
>
> 默认段与之前相同

- 例如：MOV AX,MASK[BX] [SI]或MOV AX,[MAXK+BX+SI]

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEd24429924d26f99c7777f586a64a6b86/318)

#### 4.4、与转移地址有关的寻址方式

- 这种寻址方式用来确定转移指令及CALL指令的转向地址
- 是用来告诉CPU如何修改CS和IP的值，以达到控制程序转移的目的

##### 4.4.1、段内直接寻址

> 转向的有效地址是当前IP寄存器的内容和指令中指定的8位或16位位移量之和

### 5、80x86指令系统

> 80x86大多数指令技能处理字数据，又能处理字节数据
>
> 算术运算和逻辑运算不局限于累加器
>
> 存储器操作数也可以直接参加算术逻辑运算
>
> 80x86指令系统：
>
> 1. 数据传送
> 2. 算术运算
> 3. 逻辑运算
> 4. 串操作
> 5. 程序控制
> 6. 处理器控制
>
> 汇编语言指令语句格式：[标号:] 指令助记符 [操作数1 [，操作数2]] [;注释]
>
> ==标号只被汇编程序识别，与指令无关==

#### 5.1、数据传送指令

- 数据传送指令负责吧数据、地址或立即数传送到寄存器或存储单元中

##### 5.1.1、通用数据传送指令

| 指令         | 作用           |
| ------------ | -------------- |
| MOV          | 传送           |
| MOVSX        | 带符号扩展传送 |
| MOVZX        | 带零扩展传送   |
| POSH         | 进栈           |
| POP          | 出栈           |
| PUSHA/PUSHAD | 所有寄存器进栈 |
| POPA/POPAD   | 所有寄存器出栈 |
| XCHG         | 交换           |

- MOV传送指令

> 格式为：MOV DST,SRC
>
> 操作：（DST）<----（SRC）
>
> 其中 DST为目的操作数，SRC为源操作数
>
> 源操作数可以是累加器、寄存器和存储单元。传送不改变源操作数
>
> MOV指令不会影响标志位
>
> ==注意：源操作数和目的操作数不能同时是段寄存器；代码段寄存器CS不能作为目的操作数；指令指针IP既不能作为源，也不能作为目的。双操作数不能两个操作数都使用存储器，所以必须有一个寄存器。目的操作数不能是立即数==

- CPU内部寄存器直接的数据传送

  ```
  MOV AH,AL
  MOV DL,DH
  MOV BP,SP
  MOV AX,CS
  ```

- 立即数送至通用寄存器或存储单元

  > 立即数不能直接传送到段寄存器
  >
  > 立即数永远不能作为目的操作数

  ```
  MOV AL,3
  MOV SL,-5
  MOV VARB,-1 ;VARB是一个变量名，代表一个存储空间
  MOV VARW,3456H；VARW是一个字变量
  ```

- 寄存器与存储器间的数据传送

  > 源操作数和目的操作数类型要一致
  >
  > 除了串操作指令外，源操作数和目的操作数不能同时是存储器操作数

  ```
  MOV AX,VARW;VARW是一个字变量，存储器操作数为直接寻址
  MOV BH,[DI];存储器操作数为寄存器间接寻址
  MOV VARB,DL;VARB是一个字节变量
  ```

```汇编
# 段机制必须通过寄存器送到DS寄存器
MOV AX,DATA_SEG
MOV DS,AX
```

- XCHG交换指令

> 格式：SCHG OPRD1,OPRD2
>
> 操作：（ OPRD1）<---->（OPRD2）
>
> 可以很方便的实现通用寄存器与通用寄存器或存储单元间的数据交换
>
> 两操作数可以是通用寄存器和存储单元。但不包括段寄存器，也不能同时是存储单元，还不能有立即数，可采用各种存储器寻址方式来指定存储单元

```汇编
XCHG BX,[BP+SI]
（BX）=6F30H （BP）=0200H （SI）=0046H （SS）=2F00H （2F246）=4154H
物理地址=2F000+0200+0046=2F246H
执行后：（BX）=4154H （2F246H）=6F30H
```

- MOVSX带符号扩展指令

>格式:MOVSX DST,SRC
>
>操作：(DST)<----带符号扩展(SRC)
>
>==该指令源操作数可以是8位或16位的寄存器或存储单元内容，而目的操作数必须是16位或32位寄存器
>
>不影响标志位

- MOVZX带零扩展传送指令

> 与MOVSX一致

- pop出栈指令与push进栈指令

> 堆栈的存取必须以字为单位
>
> 80x86不允许PUSH使用立即数寻址
>
> POP指令目的为段寄存器时，不许使用CS寄存器
>
> 堆栈的段值在堆栈寄存器SS中
>
> 堆栈指针寄存器SP始终指向栈顶
>
> ==可以使用除立即数以外的寻址方式==

- PUSH进栈指令

> 格式：PUSH SRC
>
> 执行操作：(SP)<-----(sp)-2
>
> 改制了把源操作数SRC压入堆栈。它先把堆栈指针寄存器Sp的值减2，然后把源操作数SRC送入由SP所指的栈顶
>
> SRC可以值通用寄存器和段寄存器也可以是字存储单元

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEb1ce1cb339543c8ed9e3b3a4249e1c65/324)

- POP出栈指令

> 格式：POP DST
>
> 执行操作：(SP)<------(SP)+2
>
> 该指令从栈顶弹出一个字数据到目的操作数DST
>
> DST可以是通用寄存器和段寄存器(CS例外)，也可以是字存储单元

##### 5.1.2、累加器专用传送指令

> 只能用于使用累加器AX，EAX，AL传送信息

| 指令 | 作用 |
| ---- | ---- |
| IN   | 输入 |
| OUT  | 输出 |
| XLAT | 换码 |

- IN输入指令与OUT输出指令

> 80x86中，所有的I/O端口与CPU之间的通信都用IN和OUT完成
>
> CPU只能用累加器接受和发送信息
>
> 外部设备最多可有65536个I/O端口
>
> 其中前256个端口可有直接在指令中指定，就是长格式PORT，此时机器用两个字节表示，第二个字节就是端口号
>
> 256端口号之后的只能先把端口号放在DX寄存器中，再传送信息
>
> IN与OUT提供了字节，字，双字三种模式，用那种取决于外设端口宽度

```
# 长格式为：
IN AL,PORT(字节)
# 执行操作为： (AL)<----(PORT)

# 短格式为
IN AL,DX(字节)
# 执行操作：(AL)<----(DX)
```

##### 5.1.3、地址传送指令

| 指令 | 作用             |
| ---- | ---------------- |
| LEA  | 有效地址送寄存器 |
| LDS  | 指针送寄存器和DS |
| LES  | 指针送寄存器和ES |
| LFS  | 指针送寄存器和FS |
| LGS  | 指针送寄存器和GS |
| LSS  | 指针送寄存器和SS |

- LEA有效地址送寄存器指令

> 格式：LEA REG,OPRD
>
> 该指令把操作数OPRD的有效地址传送到操作数REG
>
> 操作数OPRD必须是一个存储器操作数
>
> 操作数REG必须是一个16位的通用寄存器
>
> SRC可使用除立即操作数和寄存器操作数外的任一种存储器寻址方式

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE1751b3e3b959fab610c82488b39fecf6/320)

- LDS，LFS,LES,LGS,LSS

> 格式：LDS REG,SRC
>
> 其他指令格式与LDS格式相同，指定的段寄存器不同
>
> 执行操作：16位：(REG)<-------(SRC),(DS)<-----(SRC+2)
>
> 32位：(REG)<-------(SRC),(DS)<-----(SRC+4)
>
> 该指令把操作数SRC中所含的一个32位地址指针的段值部分送到数据寄存器DS
>
> 把偏移部分送到指令给出的通用寄存器REG
>
> 该指令的SRC只能使用存储器寻址方式
>
> REG不能使用段寄存器，往往使用变址寄存器或指针寄存器

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE350276ea4d7884dd2c40b222cbd92451/322)

##### 5.1.4、标志寄存器传送指令

| 指令         | 作用           |
| ------------ | -------------- |
| LAHF         | 标志送AF       |
| SAHF         | AH送标志寄存器 |
| PUSHF/PUSHFD | 标志进栈       |
| POPF/POPFD   | 标志出栈       |

- LAFH标志送AF

> ==采用固定寻址方式==
>
> 格式：LAFH
>
> 该指令把标志寄存器的底8位(包括SF、ZF、AF、PF和CF)传送到寄存器AH的指定位

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEbcc70465da72ce89df2b29f8a3e0d9f7/326)

- SAHF  AH送标志寄存器

> 与LAHF相反

##### 5.1.5、标志位操作指令

> 全部格式：直接指令
>
> 如：CLC

| 指令 | 名称             | 作用                |
| ---- | ---------------- | ------------------- |
| CLC  | 清进位标志指令   | 该指令使进位标志为0 |
| STC  | 置进位标志指令   | 该标志使进位标志为1 |
| CMC  | 进位标志取反指令 | 使进位标志取反      |
| CLD  | 清方向标志       |                     |
| STD  | 置方向标志       |                     |
| CLI  | 清中断允许标志   |                     |
| STI  | 置中断允许标志   |                     |



##### 5.1.6、类型转换指令

> 由于除法指令中隐含使用字被除数或双字被除数
>
> 所以当被除数为字节，或者除数和被除数均为字时
>
> 需要在除操作前扩展被除数

| 指令  | 作用           |
| ----- | -------------- |
| CBW   | 字节转换为字   |
| CWD   | 字转换为双字   |
| CDQ   | 双字转换为四字 |
| BSWAP | 字节交换       |

> 全部格式：直接指令
>
> 例如：CBW
>
> CBW：把寄存器AL中的符号扩展到寄存器AH
>
> CBD：把寄存器AX中的符号扩展到寄存器DX

#### 5.2、算术指令

##### 5.2.1、加法指令

| 指令 | 用法       |
| ---- | ---------- |
| ADD  | 加法       |
| ADC  | 带进位加法 |
| INC  | 加1        |
| XADD | 交换并相加 |

- 加法指令

> ADD格式：ADD DST  SRC
>
> 操作:(DST)<------SRC+DST
>
> ==溢出标志判断技巧，若两操作数符号相反时置1，否则为0==
>
> ==OF可以用来表示带符号数的溢出，CF可以表示无符号数的溢出==
>
> ADC与INC与ADD相同，但是INC指令不影响CF标志位
>
> INC格式：INC DST
>
> DST既可以是通用寄存器也可以是存储单元
>
> ==主要用于调整地址指针和计数器==

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE047ee7b1a346168172e6530b82ed68d3/328)

##### 5.2.2、减法指令

| 指令      | 用法            |
| --------- | --------------- |
| SUB       | 减法            |
| SBB       | 带借位减法      |
| DEC       | 减一            |
| NEG       | 求补            |
| CMP       | 比较            |
| CMPXCHG   | 比较并交换      |
| CMPXCHG8B | 比较并交换8字节 |

- 减法指令

> SUB格式：SUB DST，SRC
>
> 执行的操作 （DST)<---(DST)-(SRC)
>
> SBB格式：SBB DST,SRC
>
> 执行的操作：(DST)<----(DST)-(SRC)-CF
>
> 只要用于多字节数相减的场合
>
> DEC格式：DEC OPR
>
> 执行操作：(OPR)<------(OPR)-1
>
> ENG格式：与DEC一样
>
> 对-128和-32768取补，OF为1，其他为0
>
> ==操作数为0时求补运算结果使CF=0，其他情况都为1==
>
> CMP格式：CMP OPR1，OPR2
>
> 执行的操作：(OPR1)-(OPR)
>
> 执行减法操作，但不保存结果，只根据结果更改条件标志位
>
> 如果两个数为无符号数，则根据CF判断大小
>
> 如果两者是有符号数，则根据SF和OF判断大小
>
> ==减法有进位时CF=0，当两个数符号相反且结果的符号与减数相同则OF=1，否则为0==

- 运算例题

  ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE3aa780f02e8dad4161fadcbbf130ed76/330)

  ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE4e32d29a50ae8dfd31a50efbc0a0e834/332)

##### 5.2.3、乘法指令

| 指令 | 用法       |
| ---- | ---------- |
| MUL  | 无符号乘法 |
| IMUL | 有符号乘法 |

- 乘法指令

> MUL格式：MUL SRC
>
> 执行的操作：字节操作：(AX)<---(AL)*(SRC)
>
> 字操作：(DX,AX)<----(AX)*(SRC)
>
> 双字操作：(EDX,EAX)<---(EAX)*(SRC)
>
> 在乘法指令中一个操作数总是隐含在寄存器AL或者AX中，另一个操作数可以采用除立即数方式之外的任一寻址方式
>
> ==在乘法指令里，目的操作数必须是累加器==
>
> ==如果乘积结果的高半部分不为0，则CF=1，OF=1，否则CF=0，OF=0==
>
> ==该指令对其他标志位无定义==
>
> IMUL格式：IMUL OPRD
>
> 这条指令被乘数与乘数均为有符号数
>
> 此外与指令MUL完全类似
>
> ==如果乘积结果的高半部分不是底半部分的符号扩展则标志CF=1，OF=1，否则CF=0，OF=0==

- 例子

  > 带符号的乘法：
  >
  > 把负数求补，换成正数再相乘，再把结果按次数求补
  
  ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEbb56e967ff2162830157a97bbb682d72/334)

##### 5.2.4、除法指令

| 指令 | 用法       |
| ---- | ---------- |
| DIV  | 无符号除法 |
| IDIV | 有符号除法 |

- 除法指令

> 在除法指令中，被除数总是隐含在寄存器AX（除数是8位）或者DX和AX中（除数是16位），，另一个操作数可以采用除立即数方式之外的任一种寻址方式
>
> 无符号除法DIV格式：DIV OPRD
>
> 字节操作为：(AL)<-----(AX)/(OPRD)的商;(AH)<----(AX)/(OPRD)的余数
>
> 字操作为：(AX)<-----(DX，AX)/(OPRD)的商;(DX)<----(DX,AX)(OPRD)的余数
>
> ==如果除数为0，或者在8位数除时商超过8位。或者在16位除时商超过16位，则被认为是除溢出，引起0号中断==
>
> ==除法指令对标志位的影响无定义==
>
> 带符号除法IDIV格式与DIV一致
>
> ==商和余数必须带符号，且余数的符号与被除数符号一致==
>
> ==当除数为0，或者商太大(字节除时超过127，字除时超过32767)，或者商太小（字节除时小于-127，字除时小于-32767），引起0号中断

- 例题

  > 除法与乘法计算方式一致

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEd6896a0157ef895c00471232c62f7309/336)

##### 5.2.5、总例题

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE68c22175d8b71d76282607f4eaf19f19/340)

#### 5.3、逻辑指令

##### 5.3.1、逻辑运算指令

| 指令 | 用法   |
| ---- | ------ |
| AND  | 逻辑与 |
| OR   | 逻辑或 |
| NOT  | 逻辑非 |
| XOR  | 异或   |
| TEST | 测试   |

> 逻辑运算指令可以对字或者字节执行逻辑运算，由于逻辑运算是按位操作的，因此一般来说，其操作数应该是位串而不是数
>
> ==AND==逻辑与操作格式：AND OPR1,OPRD2
>
> 该指令对两个操作数进行按位的逻辑与运算，结果送到目的操作数中
>
> 若某个操作数与自己相与，值不变，CF为0
>
> ==与指令主要用在使一个操作数中的若干位维持不变，而另外若干位清为0的场合，把要维持不变的这些位与1相与，而把要请0的为与0相与就可以了==
>
> ==OR==逻辑或操作：OR DST,SRC
>
> (DST)<----(DST)∨(SRC)
>
> 某个值与自己相或，值不变，CF=0
>
> ==主要用在使一个操作数中若干位维持不变，而另外若干位置为1的场合。把维持不变的与0或，与变得与1或==
>
> ==NOT==逻辑非操作：NOT OPRD
>
> 这条指令把操作数取反，然后把结果送到操作数中
>
> 操作数可以是通用寄存器，也可以是存储器操作数。
>
> ==此指令对标志没有影响==
>
> ==XOR==异或操作：XOR DST,SRC
>
> (DST)<----(OPR)⊕(SRC)
>
> 某个值与自己异或则值为0，CF=0
>
> ==异或主要使用在一个操作数若干位维持不变，而另外若干位置取反。把维持不变的与0异或，把取反的与1异或
>
> ==TEST==测试指令：TEST OPRD1,OPRD2
>
> (OPRD1)∧(OPRD2)
>
> ==两个操作数相与的结果不保存，只是根据其特征置条件码==
>
> ==该指令通常用于检测某些位是否为1，但又不希望改变源操作数值的场合==
>
> ==以上指令，NOT不允许使用立即数，其他四条指令除非源操作数是立即数，至少有一个操作数必须存放在寄存器中，另一个操作数可以使用任意寻址方式。NOT不影响标志位，其他指令使CF和OF置0，AF无定义，SF，ZF，PF根据运算结果设置==

- 例子：

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE209024077cf605b4e46b0aa88ccef736/344)

##### 5.3.2、位测试并修改指令

| 指令 | 用法         |
| ---- | ------------ |
| BT   | 位测试       |
| BTS  | 位测试并置1  |
| BTR  | 位测试并置0  |
| BTC  | 位测试并变反 |

> 格式都一样：指令 DST,SRC
>
> ==BT==指令：把目的操作数中由源操作数所指定位的值送往CF
>
> ==BTS==指令：把目的操作数中由源操作数所指定位的值送往CF，并将目的操作数中的该位置1
>
> ==BTR==指令：把目的操作数中由源操作数所指定位的值送往CF，并将目的操作数中的该位置0
>
> ==BTC==指令：把目的操作数中由源操作数所指定位的值送往CF，并将目的操作数中的该位取反

##### 5.3.3、位扫描指令

| 指令 | 用法     |
| ---- | -------- |
| BSF  | 正向扫描 |
| BSR  | 反向扫描 |

> 格式都一样：指令  REG，SRC
>
> ==BSF==指令：指令从位0开始自右向左开始扫描源操作数，目的是检索第一个为1的位、遇到第一个为1的位则将ZF置0，并将该位的位位置装入到目的寄存器中；若源操作数为0，则ZF=1，目的操作数无定义
>
> ==该指令的源操作数可以用除立即数以外的任一寻址方式指定字或双字，目的操作数必须用字或双字寄存器==
>
> ==BSR==指令：指令从最高有效位开始自左向右开始扫描源操作数，目的是检索第一个为1的位、遇到第一个为1的位则将ZF置0，并将该位的位位置装入到目的寄存器中；若源操作数为0，则ZF=1，目的操作数无定义

##### 5.3.4、移位指令

| 指令 | 用法           |
| ---- | -------------- |
| SHL  | 逻辑左移       |
| SAL  | 算术左移       |
| SHR  | 逻辑右移       |
| SAR  | 算术右移       |
| ROL  | 循环左移       |
| ROR  | 循环右移       |
| RCL  | 带进位循环左移 |
| RCR  | 带进位循环右移 |
| SHLD | 双精度左移     |
| SHRD | 双精度右移     |

- 移位指令

> 格式都一样：指令  OPR,CNT
>
> ==SHL==指令：其中OPR用除立即数之外的任何寻址方式。位移次数由CNT决定，可以是1或CL。若CNT大于1，要先把移位次数放到CL寄存器中。OPR与CNT规定适用于以下全部移位指令
>
> ==SAL==指令：与SHL相同
>
> ==左移指令每左移移位，右边用0补位，移出的最高位进入标志位CF，OF只有移位一次才为1，其他无定义==
>
> ==只要左移以后的结果未超过一个字节或一个字的表达范围，每左移一次，源操作数的权增加一倍，也就是原数乘以2==
>
> ==一般来说算术左移当做有符号数，逻辑左移当做无符号数==
>
> ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEca093b10330579be530a35621d8f5c00/347)
>
> ==SHR==指令：左边用0补足，移出的最低位进入标志位CF
>
> ==SAR==指令：==这里的最高位右移，同时用它自身的值填入，即原来是0仍为0。移出的最低位进入标志位==
>
> 对于有符号或无符号数而言，算术右移一位相当于除以2
>
> ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEbbc26eb377bea829d3a4249671543de3/349)

- 循环移位指令

> 格式都一样：指令 OPR,CNT
>
> ==ROL==
>
> ==ROR==
>
> ==RCL==
>
> ==RCR==
>
> 对于不带进位的循环移位指令，移动操作位数的次数就能复原。对于带进位的循环指令，如果操作数是8位的，移位9次复原，如果操作数是16位的，移位7次复原
>
> ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE4856fb8a2b7a960d678f821d3086b0f9/351)

- 以上两组指令都能作字或字节操作。它们对条件码的影响是：CF根据结果设置。OF只有当CNT=0时才有效，否则无定义。当CNT=1时，在移位后最高有效位的值发生变化时(原来为1，移位后为0；原来为0，移位后为1)，OF为1，否则为0。循环移位指令只对CF和OF有影响。移位指令只对AF无定义。

- 双精度移位指令

> 格式都一样：指令 DST,REG,CNT
>
> 该指令为三操作数指令，DST可以用除立即数的任一寻址方式。源操作数只能使用寄存器方式指定与目的操作数相同长度的字或双字，第三个数指定移位次数
>
> 这组指令可以取两个字做移位操作而得到一个字的结果；也可以去两个双字得到一个双字的结果。在移位中，作为源操作数的寄存器提供移位值，以补目的操作数因位移引起的==空缺==，而指令完成后，==只取目的操作数作为移位的结果==，源操作数的值==不变==
>
> 指令主要用于边界不对准的位串传送中
>
> 对标志位影响与上一致

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEcf3cb3cfb5911c7cc75f36bb04cf84a1/353)

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE0b83fbaebd0f8818d48a4b466b3060e0/355)

##### 5.3.5、串处理指令

| 指令 | 用法   |
| ---- | ------ |
| MOVS | 串传送 |
| CMPS | 串比较 |
| SCAS | 串扫描 |
| LODS | 从串取 |
| STOS | 存入串 |
| INS  | 串输入 |
| OUTS | 串输出 |

| 指令配合前缀 | 作用                |
| ------------ | ------------------- |
| REP          | 重复                |
| REPE/REPZ    | 相等/为0则重复      |
| REPNE/REPNZ  | 不相等/不为零则重复 |

##### 5.3.6、控制转移指令

- 无条件转移指令-JMP

> JMP 跳转指令
>
> 无条件的转移到指令指定的地址去执行从该地址开始的指令。JMP指令必须指定转移的目标地址
>
> 转移分为段内转移和段间转移。
>
> 段内转移是指在同一段的范围内进行转移，此时只需要改变IP或EIP寄存器的内容，即用新的转移目标地址代替原有的IP或EIP的值就能达到转移的目的。
>
> 段间转移则是要转到另一个段去执行程序，此时不仅要修改IP和EIP寄存器的内容，还需要修改CS寄存器的内容才能达到目的。因此，此时的转移目标地址应由新的段地址和偏移地址组成

- 无条件段内直接转移指令

> 格式：JMP 标号(操作码  地址差)
>
> 地址差：是程序中无条件转移指令的下一条指令的开始地址到转移目标地址的(标号所指定指令的开始地址)差值
>
> 标号为IP+地址差：IP=IP+地址差
>
> 所以该指令的实际动作是吧指令中的地址差加到指令指针IP上
>
> 这条指令使控制无条件的转移到标号地址处
>
> ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEe34360b4054860b5c08181a7864a8a87/357)
>
> 地址差可以是一个字节也可以是一个字
>
> 如果地址差为一个字节称为短转移：
>
> ​									JMP NEAR PTR PROG
>
> 如果地址差为一个字称为近转移:
>
> ​									JMP SHORT QUEST
>
> ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEea9fbfc5a1236804cb0daf1fce154cc4/359)

- 无条件段内间接转移指令

> 格式：JMP OPRD
>
> 该指令使控制无条件的转移到由操作数的内容给定的目标地址处
>
> OPRD可以是通用寄存器，也可以是字存储单位
>
> ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEbbe301c73b6658bbc5e9d2eed182cc56/361)

- 无条件段间直接转移指令

> 格式：JMP FAR PTR 标号
>
> 这条指令使控制无条件转移到标号对应的地址
>
> FAR PTR表明这是段间转移
>
> 例如：JMP FAR PTR EXIT(EXIT是另一个代码段中的标号)
>
> 无条件段间直接转移指令的具体动作是把指令中包含的目标地址的段值和偏移分别置入CS和IP
>
> 这种在指令中直接包含转移目标地址的转移方式称为绝对转移

- 无条件段间间接转移指令

> 格式：JMP OPRD
>
> 这条指令使控制无条件的转移到由操作数OPRD的内容给定的目标地址处。OPRD必须是双字存储单元
>
> 例如：JMP DWORD PTR [1234H]；双字存储单元的底字内容送IP
>
> ​															；双字存储单元的高字内容送CS

- 无条件例题

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEe0f7e33dff1321853b4542c793a6f57e/363)

##### 5.3.7、条件转移指令

- 条件转移指令根据某标志位或某些标志位的逻辑运算来判别条件是否成立，如果成立则转移，否则继续顺序执行
- 所有的条件转移都只是段内转移
- 条件转移不影响标志位

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE7d66795caee1eb75bb480bf892d119b8/365)

- 根据单个条件标志的设置情况转移

> ==JZ(JE)==结果为零（相等）则转移
>
> 格式：JZ（JZ） OPR
>
> 测试条件 ZF=1
>
> ==JNZ(JNE)==结果不为零(不相等)就转移
>
> 格式：JNZ(JNE) OPR
>
> 测试条件：ZF=1
>
> ==JS==结果为负则转移==JNS==
>
> 格式：JS OPR
>
> 条件：SF=1
>
> ==JO==溢出则转移==JNO==
>
> 格式：JO OPR
>
> 条件：OF=1
>
> ==JP(JPE)==奇偶位为1则转移==JNP(JPO)==
>
> 格式：JP OPR
>
> 条件：PF=1
>
> ==JB（JNAE，JC）==低于，或者不高于或等于，或进位为1则转移
>
> ==JNB(JAE,JNC)==不低于，或高于或等于，或进位为0则转移
>
> 格式：==JB==（JNAE，JC） OPR
>
> 条件：CF=1

- 比较两个无符号数

> ==JB(JNAE,JC)==
>
> ==JNB(JAE,JNC)==
>
> 与1中最后两个相同
>
> ==JBE（JNA）==低于或等于，或不高于则转移
>
> ==JNBE（JA）==不低于或等于，或不高于则转移
>
> 格式：JBE（JNA）OPR
>
> 条件：CF∨ZF=1

- 比较两个带符号数

> ==JL(JNGE)==小于，或者不大于或等于则转移
>
> ==JNL（JGE）==不小于，或者大于或等于则转移
>
> 格式：JL(JNGE) OPR
>
> 条件：SF⊕OF=1
>
> ==JLE（JNG）==小于或等于，或者不大于则转移
>
> ==JNLE（JG）==不小于或等于，或者大于则转移
>
> 格式：JLE（JNG）OPR
>
> 条件：（SF⊕OF）∨ZF=1

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEdc6fe92c636238d5a45bdd7e8689e2f0/375)

- 两数是否相等可由ZF反映，CF反映两无符号数比较后的大小关系，两有符号数由SF和OF一起反映

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE683821674d82515509a12aab408b096f/367)

- 测试CX或ECX的值为0则转移指令

> ==JCXZ==  cx寄存器的内容为0则转移
>
> ==JECXZ==
>
> 格式：JCXZ OPR
>
> 条件：（CX）=0
>
> ==指令只能提供8位位移量，也就是说只能进行短转移==
>
> ==通常使用在循环开始前，以便在循环次数为0时跳过循环体==
>
> ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE51224002a68cdbe96023637c63165a3d/381)

- 例题

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEa6e396c5cfcde2331fcc12ce5bdea5f8/369)

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE48ae35e974ef6c91289159e03450314d/371)

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEb7319ef4cdfc051e891900cbe1e9b2fd/373)

##### 5.3.8、条件设置指令

##### 5.3.9、循环指令

| 指令          | 作用                   |
| ------------- | ---------------------- |
| LOOP          | 循环                   |
| LOOPZ/LOOPE   | 当为零或相等时循环     |
| LOOPNZ/LOOPNE | 当不为零或不相等时循环 |

> 格式都一样：指令  OPR
>
> ==LOOP==计数循环指令
>
> 条件：（Count Reg）！=0
>
> 这条指令使寄存器CX的值减1，如果结果不等于0，则转移标号，否则顺序执行
>
> ==通常在使用LOOP指令构成循环时，先要设置好计数器CX的处置，即循环次数==
>
> ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE63ad5b67ec528ce42f19a65bc4ba32de/377)
>
> ==LOOPZ/LOOPE==  当为零或相等时循环指令
>
> 条件：ZF=1且（Count Reg）！=0
>
> 该指令使CX的值减1，当为0或相等时（且ZF=1），那么转移到标号，否则顺序执行
>
> ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE1da8305f154881fe5fc22d2829de1bcb/379)
>
> ==LOOPNZ/LOOPNE==    当不为零或不相等时循环指令
>
> 条件：ZF=0且（Count Reg）！=0
>
> 以上指令执行步骤为：
>
> 1. （Count Reg）<-----（Count Reg）-1
> 2. 检查是否满足测试条件，如满足且操作数长度为16位，则(IP)<----(IP)+D8的符号扩展；如满足且操作数长度为32位时，则(EIP)<----(EIP)+D8的符号扩展
>
> 循环指令也采用相对转移的方式，即通过在IP上加一个地址差的方式实现转移，循环指令中也只用一个字节来表示地址差
>
> 如果以循环指令本身作为基准，那么循环转移的范围在-126到+129之间
>
> 循环指令不影响标志

- 例题

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE4e08d6d399f27be6cbbeb85259ab8478/383)

#### 6、伪指令语句

- 汇编语言语句
  1. 指令语句
  2. 伪指令语句
  3. 宏指令
- 伪指令语句==没有与其对应的机器指令==，只是指示汇编程序如何汇编源程序，包括符号的定义、变量的定义、段的定义、处理器的选择、定义程序模式、定义数据、分配存储区、指示程序结束等。
- 伪指令在汇编程序对源程序汇编期间由汇编程序处理的操作
- 伪指令语句格式

> (名字) 操作项(参数，参数)(;注释)
>
> 伪指令定义符规定了伪指令的功能
>
> ==标号与名字的区别==：标号后面带有冒号，名字没有
>
> ==标号与名字命名规则==:一般由31个字母、数字及规定的特殊字符(?@_$)等组成，并且不能由数字开头组成
>
> 伪指令的==参数==可以是一般符号、特殊意义的符号、常数或者表达式

##### 6#、地址表达式及变量与标号

- 表示的是存储器操作数的地址

- 单个的标号、变量(对应直接寻址方式)和有方括号括起的基址或变址寄存器(对应寄存器间接寻址)是地址表达式的特例

- 一个存储地址可进行加减运算

  ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE6a6dbf75bb08c356b9a57ae48955658f/395)

- 变量与标号分表代表存储单元

  - 变量表示的存储单元中存放数值
  - 标号表示的存储单元存放指令代码
  - 都具有以下三种属性：
    1. 段值：变量或标号对应存储单元所在段的段值
    2. 偏移：变量或标号对应存储单元的起始地址的段内偏移
    3. 类型：变量的类型主要是BYTE等，标号的类型主要是NEAR和FAR，近表示段内标号，远表示段间标号

##### 6.1、常数

- 十进制常数

  - 通常情况下汇编程序的常数由十进制数表示，所以一般不加后缀字母D，但汇编语言提供==改变基数的伪指令==RADIX

    ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE8ede8982c0cc6a4a59cb4f87346d0fda/385)

- 十六进制常数

  - 必须由字母H结尾，十六进制必须由数字开头，所以以字母开头的16进制数需要在前面加一个0

- 二进制数

  - 必须由字母B结尾

- 八进制常数

  - 必须由字母Q结尾

- 字符串常数

  - 由引号括起来的一个或多个字符
  - 串常数的值是包括在引号中的字符的ASCLL代码值

  ```
  例如：'A'为41H
  'ab'为6162H
  ```

##### 6.2、操作项

###### 6.2.1、算术操作符符

- 包括+正、-负、+、-、*、/和MOD模

  ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEa9be609058fac5a6963a0cc93d6227bf/387)

###### 6..2.2、关系操作符

- 包括相等(EQ),不等(NE),小于(LT),大于(GT),小于或等于(LE),大于或等于(CE)
- 运算结果是一个数字值
  - 关系成立结果为0
  - 不成立则为0FFFFH

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEc966ef183688a163aaaa4101b0387235/389)

###### 6.2.3、逻辑与移位操作符

- 包括与(AND)、或(OR)、异或(XOR)、非(NOT)、左位移(SHL)、右位移(SHR)

- 逻辑运算的结果也是数值

  ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEfe3b58cf38f8c8274cd892dc85f13ee0/391)

###### 6.2.4、字节分离操作符

| 操作符 | 使用格式    | 运算结果          |
| ------ | ----------- | ----------------- |
| HIGH   | HIGH 表达式 | 数值表达式的高8位 |
| LOW    | LOW 表达式  | 数值表达式的底8位 |

![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCE33a797a0a8dbe83f45fff457bbe0efbd/393)

###### 6.2.5、数值回送操作符

- 这些操作符把一些特征或存储器地址的一部分作为数值传送
- 主要包括TYPE,LENGTH,SIZE,OFFSET,SEG等

1. TYPE

> 格式：TYPE 操作数项
>
> DB为1，DW为2，DD为4，DF为6，DQ为8，DT为10
>
> 例如： ARRAY DW 1,2,3
>
> ​			ADD SI，TYPE ARRAY
>
> 等同于：ADD SI，2

2. LENGTH

> 格式：LENGTH 操作数项
>
> 回送对于操作数项由DUP分配的空间单元数，对于其他情况回1
>
> LENGTH FEES DW 100 DUP(?)
>
> 等同于100

3. SIZE

> 格式一致
>
> 回送分配给该变量的字节数，但是此值是LENGTH和TYPE的乘积
>
> SIZE FEES
>
> 等同于200

4. SEG

> 格式一致
>
> 回送变量或标号的段地址值
>
> 如果FEES在段地址为05000H的数据段，则SEG FEES回送为05000H

5. OFFSET

> 格式一致
>
> 汇编程序将回送变量或标号的偏移地址

###### 6.2.6、属性操作符

> 主要包括PTR、段操作符、SHORT、THIS、HIGH、LOW、HIGHWORD、LOWWORD

1. PTR

> 格式：type PTR expression
>
> PTR用来建立一个符号地址，但本身并不分配存储器，只是给已经分配的存储器地址赋予另一种属性，使该地址具有另一种属性 
>
> tow_byte DW ?
>
> ONE_byte EQU BYTE PTR two_byte
>
> tow_byte与ONE_byte具有相同的段地址和偏移地址，但是前者的类型属性为2，后者为1

2. 段操作符

> 用来表示一个标量、变量或地址表达式的段属性
>
> 例如：MOV AV，ES:[BX+SI]
>
> 所以是用名字加地址表达式来表示其属性

3. SHORT

> 用来修饰JMP指令中转向地址的属性，指出转向地址是在下一条指令地址的<u>+</u>127个字节范围之内

4. THIS

> 类似于PTR，但是是与下一个存储空间的段地址与偏移地址相同
>
> 例如：first EQU THIS BYTE
>
> ​			second DW 100 DUP(?)
>
> first与second的段地址与偏移地址相同，但是类型不同

5. HIGH和LOW:字节分离操作符

6. HIGHWORD和LOWWORD：字分离操作符

##### 6.2#、操作项的优先级

1. 在圆括号中的项，方括号中的项、结构变量、LENGTH、SIZE、WIDTH、MASK
2. 名：(段取代)
3. PTR,OFFSET,SEG,TYPE,THIS及段操作符
4. HIGH,LOW
5. 乘法和除法:*,/,MOD,SHL,SHR
6. 加法和减法
7. 关系操作符
8. 逻辑操作符：NOT
9. 逻辑操作符：AND
10. 逻辑操作符：OR,XOR
11. SHORT

##### 6.3、程序开始与结束伪指令

> 在程序的==开始==可以用NAME或TITLE作为模块的名字
>
> ==NAME==格式为：NAME module_name
>
> ==TITLE==格式为：TITLE text
>
> 汇编程序会把module_name作为模块名。会把text的前六个字符作为模块名，text可以有60个字符，TITLE可以指定列表文件的每一页打印的标题。
>
> 如果既没有NAME也没有TITLE会把源程序名作为模块名
>
> 表示源程序==结束==的操作：END [label]
>
> 标号label表示程序开始执行的起始地址

##### 6.4、数据定义

- 通过数据定义语句可为数据项分配存储单元，并根据需要设置其初值。还可用符号代表数据项，此时符号就与分配的存储单元相联系，此时符号就被称为变量

- 格式

  > [变量名] 数据定义符 表达式[,表达式，表达式]；注释
  >
  > ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEcb00d728646ce6ce455429ab0c73d869/397)

- 数据定义符

  | 数据定义符 | 作用                                                         | 实例                                                         |
  | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | DB         | 定义一个字节，其后的每一个操作数都占有一个字节               | ![](https://note.youdao.com/yws/public/resource/92933d878935240680c00793fc3e404c/xmlnote/WEBRESOURCEe1aa73a83383ec369cf84534cdd49f1e/400) |
  | DW         | 定义字，可以存储地址                                         |                                                              |
  | DD         | 定义双字，可以存储地址                                       |                                                              |
  | DF         | 定义6个字节的字，可以存储由16位段地址及32位偏移地址组成的远地址指针 |                                                              |
  | DQ         | 定义四字                                                     |                                                              |
  | DT         | 定义10个字节                                                 |                                                              |

- ？操作数

  - 操作数？可以保留存储空间但不存入数据

  ```
  例如：ABC DB 0,?,?,1
  ```

- 复制操作符(DUP)

> 格式：repeat_count DUP (表达式，表达式)
>
> repeat_count代表要复制的次数
>
> 表达式代表要复制的数
>
> ==例如==：A DB 2 DUP(0,1,2,3)
>
> 把0,1,2,3复制2次，所以A一共占据8个字节 

- 操作数的类型属性

> 用数据定义符定义数据赋予数据隐性的类型属性
>
> 但在汇编中可以用PTR属性操作符来定义数据类型属性：
>
> type PTR 地址表达式
>
> ==type==：DB----->BYTE
>
> ​			DW----->WORD
>
> ​			DD----->DWORD
>
> ​			DF----->FWORD
>
> ​			DQ----->QWORD
>
> ​			DT----->TBYTE
>
> ==PTR属性操作符优先于隐含的类型属性==
>
> ==例如==：MOV AL BYTE PTR OPE
>
> ​			MOV AX WORD PTR OPE
>
> 第一句意思是把OPE中第一个字节内容传送给AL
>
> 第二句为把OPE第一个字内容传送给AX

##### 6.4、LABEL伪指令

> 从以上PTR属性操作符的例子可以看出同一个变量可以具有不同的类型属性
>
> 除了用属性操作符定义外，还可以用LABEL伪指令来定义
>
> ==格式==：
>
> 对于数据项：name LABEL type
>
> 对于可执行的代码：name LABEL type
>
> 对于可执行的代码的type可以为NEAR和FAR
>
> 对于16位NEAR为2位，FAR为4位
>
> 对于32位NEAR为4位，FAR为6位
>
> ==例如==：BYTE_ARRAY LABEL BYTE
>
> ​			WORD_ARRAY DW 50 DUP(?)
>
> 这样就把100个数组的首地址赋予BYTE_ARRAY和WORD_ARRAY两个变量名

##### 6.5、表达式赋值伪指令EQU

> 当在程序中多次重复出现表达式，则可以用EQU给表达式赋予一个名字
>
> 格式：name EQU expression
>
> 例如 DATA EQU HEIGHT+2
>
> 把后面表达式赋予一个DATA、名字，但如果表达式中有变量，则要在变量定义之后才可执行赋值，否则报错
>
> 另外：=与EQU作用差不多，但是=可以重复赋值，EQU不行
>
> 例如：e=2
>
> ​			e=e+1

##### 6.6、地址计数器与对准伪指令

###### 6.6.1、地址计数器$

> 使用地址计数器来保存当前正在汇编指令的偏移地址。当开始汇编或在每一段开始时，把地址计数器初始化时为零，以后每处理一条指令，地址计数器就增加一个值
>
> $在==指令==中时代表指令的首地址
>
> $在==伪指令==中表示段地址计数器当前的值

###### 6.6.2、ORG伪指令

> ORG用来设置当前地址计数器的值
>
> 格式为：ORG expression
>
> 可以用来修改下一个字节的地址

###### 6.6.3、EVEN伪指令

> 使下一个变量或指令开始于偶数字节地址
>
> 格式：EVEN

###### 6.6.4、ALIGN伪指令

> 用来保证双字数组边界从4的倍数开始创造了条件
>
> 格式为:ALIGN boundary
>
> 参数必须是2的幂

##### 6.7、段定义伪指令
