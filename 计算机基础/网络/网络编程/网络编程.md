- 网络通信解决的是什么问题？
    - 解决应用程序之间的通信问题
    - 每个应用程序都要有自己的socket对象

- c/s模型
    - clent：主动发送请求
    - server：被动接收请求，响应有组织的数据

- TCP：传输控制协议
- UDP：报文传输协议

 - socket是什么？
    - 套接字
    - 一般应用程序会起一个监听socket
    - 对每个连接会创建一个已连接socket
    - 每个socket会有自己的文件描述符
    - 主要设计理念是为了提高并发能力

一般来说socket编程分为以下几个步骤

server

- 创建socket对象
- 绑定ip和端口
- 监听
- accetp从连接队列中取连接
- recv/senf数据
- 关闭监听socket

client：

- 创建socket对象
- 向指定地址发送连接请求
- recv/senf数据
- 关闭连接socket

socket五元组：

∙协议 (Protocol)​​：TCP 或 UDP。

∙源 IP 地址 (Source IP Address)​​：本地主机的 IP。

∙源端口号 (Source Port)​​：本地应用程序使用的端口。

∙目标 IP 地址 (Destination IP Address)​​：通信对象的 IP。

∙目标端口号 (Destination Port)​​：通信对象应用程序监听的端口。

监听socket只有前面三个，因为不需要知道目标IP和端口，目的就是为了等一个连接。socket虽然有fd，但跟磁盘上的文件还是不太一样的，fd直接指向的是底层的连接信息，是在操作内核中的数据结构。通过让文件描述符指向一个特殊的 inode，而这个 inode 又关联到内核 Socket 对象，Linux 实现了用操作文件的接口（read/write）来操作网络连接。这简化了编程模型。

为什么不关闭已连接socket？

- 一般来说，小程序在最后才会关闭监听socket，而整个主线程的结束会导致所有连接关闭，已连接socket也会随之关闭
- 但如果是长时间运行的程序，必须手动关闭每一个已连接socket。否则会导致fd资源耗尽

客户端的主动断开只会触发TCP协议层的连接终止流程（四次挥手），这会改变服务端内核中对应Socket的状态，并通知正在读写该Socket的服务端应用程序。但是，​**​服务端应用程序仍然必须主动调用 `close()`函数来释放这个Socket所占用的资源（文件描述符和内存）。​**

- 连接过程图

- 全连接和半连接队列
    - 

- 如果不从连接队列中拿连接会怎么样？
    - ​**​在 `accept`函数调用之前，等待的连接是以“数据结构”的形式存在于操作系统内核的TCP协议栈中
    - **它们是以 `struct request_sock`或 `struct sock`等内核数据结构的形式，存在于操作系统内核协议栈的TCP模块中的两个队列里。**
    - 客户端的IP地址和端口号
    - 本地（服务器）的IP地址和端口号
    - TCP的状态序列号（SEQ, ACK numbers）
    - 各种TCP定时器