# 1 传输服务和协议

- 传输层为运行在不同主机上的应用进程提供逻辑通信
- 传输协议运行在端系统
	- 发送方：将报文拆分成报文段，交给网络层
	- 接收方：将报文段合并为报文，交给应用
- 协议可选择TCP和UDP
	- TCP：可靠的保序的传输
		- 多路复用，解复用
		- 流量控制
		- 拥塞控制
		- 面向连接
	- UDP：不可靠，不保序的传输
		- 多路复用，解复用
		- 没有为IP服务添加更多的额外服务
	- 都不提供时延和带宽保证的服务
# 2 多路复用和解复用

- 在发送方主机多路复用：
	- 从多个套接字接收多个进程的报文，根据套接字对应的IP地址和端口等信息对报文段用头部加以封装（该头部信息用于以后的解复用）
- 在接受方解复用
	- 根据报文段中的IP和端口信息将收到的报文段交给正确的套接字和对应的应用进程

> 多路解复用工作原理

- 解复用作用：TCP或UDP实体根据某些信息，把报文段的数据部分交给正确的socket，从而交给正确的进程
- 主机收到IP数据报
	- 每个数据报中包含源IP和目标IP
	- 每个数据报中包含一个数据段
	- 数据段有源端口和目标端口
- 主机联合使用IP和端口将报文发给合适的套接字
# 3 无连接传输 UDP

> UDP特性

- 尽力而为的服务，报文段
	- 可能丢失
	- 可能乱序
- 无连接：
	- UDP发送端和接收端之间没有握手
	- 每个UDP报文都被独立处理
- UDP被用于：
	- 流媒体
	- DNS
	- SNMP
- 在UDP上实现可靠传输
	- 在应用层增加可靠性
	- 应用特定的差错恢复

> UDP：用户数据报协议

**为什么需要UDP？**

- 不建立连接（会增加延时）
- 简单：发送方和接收方没有连接状态
- 报文段头部很小
- 无拥塞控制和流量控制：可以尽可能快的发送报文段

![[第3章：传输层_time_1.png]]

> UDP校验和

- 目标：检测在被传输报文段中的差错

- 发送方：
	- 将报文段的内容视为16比特的整数
	- 校验和：报文段的加法和（1的补运算）
	- 发送方将校验和放在UDP的校验和字段
- 接受方：
	- 计算接收到的报文段的校验和
	- 判断是否和报文段中的校验和一致

# 4 可靠数据传输的原理

**信道的不可靠特点决定了可靠数据传输协议(rdt)的复杂性**

- 使用有限状态机(FSM)来描述发送方和接收方
	- 状态：在该状态时，下一个状态只由下一个事件唯一确定

![[第3章：传输层_time_2.png]]

> Rdt1.0：在可靠信道上的可靠数据传输

![[第3章：传输层_time_3.png]]

> Rdt2.0：具有比特差错的信道

- 下层信道可能会出错：将分组中的比特反转
	- 用校验和来检测比特差错
- 问题：怎样从差错中恢复
	- 确认(ACK)：接收方显式的告诉发送方分组已被正确接收
	- 否定确认(NACK)：接收方显式告诉发送方分组出现了差错
		- 发送方接收到NACK后重传分组
	- rdt2.0新机制：采用差错控制编码进行差错检测
		- 发送方差错控制编码，缓存
		- 接收方使用编码捡错
		- 接收方的反馈：控制报文(ACK,NACK)
		- 发送方收到反馈相应的动作

![[第3章：传输层_time_4.png]]

> rdt2.1 ：ACK/NACK出错

- 接收方发送的确认信号出错，导致发送方不知道具体信号
- 引入新的机制：序号
	- 发送方在每个分组中加入序号
	- 如果ACK/NACK出错则发送方重传当前分组
	- 接收方丢弃重复分组，重新给信号

- **停等协议：** 发送方发送一个分组，然后等待接收方的应答

![[第3章：传输层_time_5.png]]

> rdt2.2 : 无NACK的协议

- 功能同rdt2.1，但只使用ACK
- 接收方对最后正确接收的分组发ACK，以代替NAK
	- 接收方必须显式的包含正确接收分组的序号
- 当收到重复的ACK时，发送方与收到NAK一样的动作：重传当前分组
- 为后面的一次发送多个数据单位做一个准备
	- 一次能发送多个
	- 每一个的应答都有两个状态比较麻烦，不使用NAK确认信息减少一半，协议处理简单

![[第3章：传输层_time_6.png]]

> rdt3.0: 具有比特差错和分组丢失的信道

- 方法：发送方等待ACK一段合理的时间
- 发送方超时重传
- 问题：如果分组或ACK只是延时了
	- 重传会导致数据重复，但可以利用序列号解决这个问题
	- 接收方必须正确指明接收的序列号
- 需要一个倒计时定时器

![[第3章：传输层_time_7.png]]

在链路容量比较大的情况下，性能很差

![[第3章：传输层_time_8.png]]

> 流水线协议

- 流水线：允许在发送方未得到对方确认的情况下一次发送多个分组
	- 必须增加序号的范围：用多个bit表示分组的序号
	- 在发送方/接收方要有缓冲区
	- 两种通用的流水线协议：回退N步（GBN）和选择重传（SR）

- 发送缓冲区：
	- 形式：内存中的一个区域，落入缓冲区的分组可以发送
	- 功能：用于存放已经发送但没有得到确认的分组
	- 必要性：需要重发时可用
- 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组
	- 停止等待=1
	- 流水线协议>1，不能过大，链路利用率不能超100%
- 发送缓冲区中的分组
	- 未发送的：落入发送缓冲区的分组，可以连续发送出去
	- 已经发送出去的，等待对方确认的分组：发送缓冲区的分组只有得到确认才能剔除

> 滑动窗口协议-slide-window

- 发送窗口：发送缓冲区内容的一个范围
	- 那些已发送但未得到确认分组的序号构成的空间
- 发送窗口的最大值<=发送缓冲区的值
- 一开始：没有发送任何一个分组
	- 后沿=前沿
	- 之间为发送窗口的尺寸=0
- 每发送一个分组，前沿前移一个单位
- 发送窗口的极限不能超过发送缓冲区

- 发送窗口后沿移动
	- 条件：老分组得到确认
	- 结果：发送缓冲区落入新的分组，来了分组可以发送
	- 移动的极限：不能超过前沿

- 接收窗口
	- 接收窗口=接收缓冲区
		- 接收窗口用于控制那些分组可以接收
			- 只有收到的分组序列号落入接收窗口内才允许接收
			- 如序号在接收窗口之外则丢弃
		- 接收窗口=1，则只能顺序接收
		- 接收窗口>1，则可以乱序接收
			- 但提交接收窗口之内的分组要按顺序

- 正常情况下两个窗口的互动
	- 发送窗口：
		- 有新分组落入发送缓冲区范围，发送->前沿移动
		- 来了老的低序列号的确认->后沿向前移动->新的分组可以落入发送缓冲区的范围
	- 接收窗口：
		- 收到分组，落入接收缓冲窗口范围内，接收
		- 是低序列号，发送确认给对方

- 异常情况下GBN的2窗口互动
	- 发送窗口：
		- 新分组落入发送缓冲区范围，发送->前沿移动
		- 超时重传机制让发送窗口内的所有分组重新发送
		- 来了老分组的重复确认->后沿不向前移动->新的分组无法落入发送缓冲区的范围
	- 接收窗口：
		- 收到乱序分组，没有落入到接收窗口范围内，丢弃
		- (重复)发送老分组的确认，累计确认

- 异常情况下SR的2窗口互动
	- 发送窗口：
		- 新分组落入发送缓冲区范围，前沿向前移动
		- 收到乱序分组的确认，后沿无法向前移动，前沿无法移动，有新的分组无法落入到发送缓冲区访问
		- 每个分组维护一个超时计时器，哪个分组超时就重发哪个分组
	- 接收窗口：
		- 收到乱序分组，落入到接收缓冲区的范围内，接收
		- 单独发送该分组的确认

> GBN协议和SR协议的异同

- 相同：
	- 发送窗口>1
	- 一次性可以发送多个分组
- 不同：
	- GBN的接收窗口=1
		- 接收端：只能按顺序接收
		- 发送端：从表现来看，一旦一个分组没有发送成功，这个分组后的所有分组都要重新发送
	- SR的接收窗口>1
		- 接收端可以乱序接收
		- 发送端可以只重传未确认或超时的分组

![[第3章：传输层_time_9.png]]