# 01-理解平均负载

> 本章内容包括：
>
> * 如何理解平均负载
> * 平均负载为多少时合理
> * 平均负载和CPU使用率区别
> * 模拟场景并排查原因
> * 了解常见进程状态

## 1 平均负载是什么

每次发现系统变慢时，我们通常做的第一件事，就是执行top或者uptime命令，来了解系统的负载情况。如下所示：

```bash
$ uptime
 15:20:28 up 97 days,  4:03,  1 user,  load average: 1.00, 1.03, 1.06
```

但对于这个命令的每一列输出，你都明白其含义吗？

```
15:20:28：当前时间
up 97 days,  4:03：已经运行的时间
1 user：当前登录用户数
load average：后面三个数字分别是1分钟、5分钟、15分钟的平均负载
```

uptime命令返回的信息中，我们最关注的就是平均负载。但我们真正理解它背后的含义吗？接下来我们就学习下如何观测和理解这个最常见、也是最重要的系统指标。

我们可以使用`man uptime`来看下平均负载的详细解释。

```
System  load  averages  is the average number of processes that
       are either in a runnable or uninterruptable state.   A  process
       in  a  runnable state is either using the CPU or waiting to use
       the CPU.  A process in uninterruptable  state  is  waiting  for
       some  I/O  access, eg waiting for disk.  The averages are taken
       over the three time intervals.  Load averages are  not  normal‐
       ized for the number of CPUs in a system, so a load average of 1
       means a single CPU system is loaded all the time while on  a  4
       CPU system it means it was idle 75% of the time.
```

简单来说，平均负载是指单位时间内，系统处于**可运行**和**不可中断**状态的平均进程数，也就是平均活跃进程数，它和CPU使用率并没有直接关系。这里先解释下可运行状态和不可中断状态。

所谓可运行状态的进程，是指**正在使用CPU或者正在等待CPU的进程**，也就是我们常用ps命令看到的处于R状态(Running或Runnable)的进程。

不可中断状态的进程则是**处于内核态关键流程中的进程**，并且这些流程是不可打断的，比如最常见的是等待硬件设备的I/O响应，也就是在ps命令中看到的D(UninterruptibleSleep,也称为Disk Sleep)状态的进程。

比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果这时候打断进程，就容易出现磁盘数据和进程数据不一致的问题。

所以，不可中断状态实际上是对进程和硬件设备的一种保护机制。

可以查看一下常见的进程状态：[常见进程状态](01-理解平均负载.md#常见进程状态)

因此，你可以简单理解为，**平均负载其实就是平均活跃进程数**。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值(指数衰减移动平均（Exponential Moving Average, EMA）算法。)。这个“指数衰减平均”的详细含义你不用计较，这只是系统的一种更快速的计算方式，你把它直接当成活跃进程数的平均值也没问题。

既然平均的是活跃进程数，那么最理想的，就是每个CPU上都刚好运行着一个进程，这样每个CPU都得到了充分利用。比如当平均负载为2时，意味着什么呢？

在只有2个CPU的系统上，意味着所有的CPU都刚好被完全占用。而在4个CPU的系统上，意味着CPU有50%的空闲。而在只有1个CPU的系统中，则意味着一半的进程竞争不到CPU。

## 2 平均负载为多少时合理

讲完了什么是平均负载，现在我们再回到最开始的例子，不知道你能否判断出，在 uptime 命令的结果里，那三个时间段的平均负载数，多大的时候能说明系统负载高？或是多小的时候就能说明系统负载很低呢？

我们知道，**平均负载最理想的情况是等于CPU个数**。所以在评判平均负载时，首先要知道系统有几个CPU，这可以通过`top`命令或者从文件`/proc/cpuinfo`中读取，比如：

```bash
$ grep "model name" /proc/cpuinfo |wc -l                      
16
```

有了CPU 个数，我们就可以判断出，当平均负载比 CPU 个数还大的时候，系统已经出现了过载。

那么这三个数据我们该着重观察哪个数据呢？

实际上，都要看。三个不同时间间隔的平均值，其实给我们提供了，分析系统负载趋势的数据来源，让我们能更全面、更立体地理解目前的负载状况。

如果1分钟、5分钟、15分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。

但如果1分钟的值远小于15 分钟的值，就说明系统最近1分钟的负载在减少，而过去15分钟内却有很大的负载。

反过来，如果1分钟的值远大于 15 分钟的值，就说明最近1分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦1分钟的平均负载接近或超过了CPU的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。

这里我再举个例子，假设我们在一个单 CPU 系统上看到平均负载为 1.73，0.60，7.98，那么说明在过去 1 分钟内，系统有 73% 的超载，而在 15分钟内，有 698% 的超载，从整体趋势来看，系统的负载在降低。

一般来看，当平均负载高于CPU数据70%的时候，就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。

但70%这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。当发现负载有明显升高趋势时，比如说负载翻倍了，你再去做分析和调查。

## 3 平均负载和CPU使用率

现实工作中，我们经常容易把平均负载和 CPU 使用率混淆，所以在这里，也对其做一个区分。

可能你会疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着 CPU 使用率高吗？

我们还是要回到平均负载的含义上来，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，**它不仅包括了正在使用 CPU的进程，还包括等待 CPU 和等待 I/O 的进程。**

而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：

* **CPU密集型进程**：使用大量CPU会导致平均负载升高，此时两者是一致的；
* **I/O密集型进程**：等待I/O也会导致平均负载升高，但CPU使用率不一定很高；\
  大量等待CPU的进程调度也会导致平均负载升高，此时的CPU使用率也会比较高。

## 4 平均负载案例分析

下面，我们以三个示例分别来看这三种情况，并用 iostat、mpstat、pidstat 等工具，找出平均负载升高的根源。

**预先准备：预先安装 stress 和 sysstat 包**

* stress：stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。
* sysstat：sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。我们的案例会用到这个包的几个命令 mpstat 和 pidstat及 iostat 。
* mpstat：mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有CPU的平均指标。
* pidstat：pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。
* iostat：iostat是一个用于监控系统输入/输出设备（如磁盘）的性能工具。它可以显示 CPU 使用情况和设备 I/O 统计信息，帮助系统管理员了解系统的 I/O 性能瓶颈。\
  安装好以上需要包，并且开三个终端都运行root用户。

### 4.1 场景一：CPU密集型进程

首先，我们在第一个终端运行stress命令，模拟一个CPU使用率100%的场景：

```bash
$ stress --cpu 1 --timeout 600
```

接着，在第二个终端运行uptime查看平均负载的变化情况：

```bash
# -d 参数表示高亮显示变化的区域 
$ watch -d uptime 
..., load average: 1.00, 0.75, 0.39
```

最后，在第三个终端运行mpstat查看 CPU 使用率的变化情况：

```bash
# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据 
$ mpstat -P ALL 5 
Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU) 13:30:06 CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 
13:30:11 all 50.05 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 49.95 
13:30:11 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 
13:30:11 1 100.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00
```

从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。

那么，到底是哪个进程导致了 CPU 使用率为100% 呢？你可以使用 pidstat 来查询：

```bash
# 间隔5秒后输出一组数据 
$ pidstat -u 5 1 
13:37:07 UID PID %usr %system %guest %wait %CPU CPU Command 
13:37:12 0 2962 100.00 0.00 0.00 0.00 100.00 1 stress
```

从这里可以明显看到，stress进程的CPU使用率为100%。

## 5 场景二：I/O密集型进程

首先还是运行 stress 命令，但这次模拟 I/O 压力，即不停地执行 sync：

```bash
$ stress -i 1 --timeout 600
```

还是在第二个终端运行uptime查看平均负载的变化情况：

```bash
$ watch -d uptime 
..., load average: 1.06, 0.58, 0.37
```

然后，第三个终端运行mpstat查看 CPU 使用率的变化情况：

```bash
# 显示所有CPU的指标，并在间隔5秒输出一组数据 
$ mpstat -P ALL 5 1 
Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU) 
13:41:28 CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 13:41:33 all 0.21 0.00 12.07 32.67 0.00 0.21 0.00 0.00 0.00 54.84 
13:41:33 0 0.43 0.00 23.87 67.53 0.00 0.43 0.00 0.00 0.00 7.74 
13:41:33 1 0.00 0.00 0.81 0.20 0.00 0.00 0.00 0.00 0.00 98.99
```

从这里可以看到，1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统CPU使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。

那么到底是哪个进程，导致 iowait 这么高呢？我们还是用 pidstat 来查询：

```bash
# 间隔5秒后输出一组数据，-u表示CPU指标 
$ pidstat -u 5 1 Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU) 
13:42:08 UID PID %usr %system %guest %wait %CPU CPU Command 
13:42:13 0 104 0.00 3.39 0.00 0.00 3.39 1 kworker/1:1H 
13:42:13 0 109 0.00 0.40 0.00 0.00 0.40 0 kworker/0:1H 
13:42:13 0 2997 2.00 35.53 0.00 3.99 37.52 1 stress 
13:42:13 0 3057 0.00 0.40 0.00 0.00 0.40 0 pidstat
```

可以发现，还是 stress 进程导致的。

## 6 场景三：大量进程的场景

当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。

比如，我们还是使用 stress，但这次模拟的是 8个进程：

```bash
$ stress -c 8 --timeout 600
```

由于系统只有 2 个CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达7.97：

```bash
$ uptime 
..., load average: 7.97, 5.93, 3.02
```

接着再运行pidstat来看一下进程的情况：

```bash
# 间隔5秒后输出一组数据 
$ pidstat -u 5 1 
14:23:25 UID PID %usr %system %guest %wait %CPU CPU Command 
14:23:30 0 3190 25.00 0.00 0.00 74.80 25.00 0 stress 
14:23:30 0 3191 25.00 0.00 0.00 75.20 25.00 0 stress 
14:23:30 0 3192 25.00 0.00 0.00 74.80 25.00 1 stress 
14:23:30 0 3193 25.00 0.00 0.00 75.00 25.00 1 stress 
14:23:30 0 3194 24.80 0.00 0.00 74.60 24.80 0 stress 
14:23:30 0 3195 24.80 0.00 0.00 75.00 24.80 0 stress 
14:23:30 0 3196 24.80 0.00 0.00 74.60 24.80 1 stress 
14:23:30 0 3197 24.80 0.00 0.00 74.80 24.80 1 stress 
14:23:30 0 3200 0.00 0.20 0.00 0.20 0.20 0 pidstat
```

可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。

## 7 常见进程状态

| 进程状态                                 | 说明                                     | 详细                                                                                      |
| ------------------------------------ | -------------------------------------- | --------------------------------------------------------------------------------------- |
| **R (Running)**                      | 进程正在运行或在运行队列中等待。                       | 这是指进程当前正在使用 CPU 资源，或者准备好使用 CPU 资源。                                                      |
| **S (Sleeping)**                     | 进程正在休眠，等待某个事件(如I/O操作完成)                | 这是指进程暂时停止执行，等待某个条件满足后继续执行。通常分为可中断睡眠（interruptible sleep）和不可中断睡眠（uninterruptible sleep）。 |
| **D (Uninterruptible Sleep)**        | 进程处于不可中断的睡眠状态，通常在等待 I/O 操作。            | 这种状态下的进程不能被信号中断，通常是因为正在等待硬件设备的响应。                                                       |
| **T (Stopped)**                      | 进程已停止，可能是因为接收到 SIGSTOP 信号或被调试器暂停。      | 进程在这种状态下不会执行任何指令，通常是被用户或调试器暂停。                                                          |
| **Z (Zombie)**                       | 僵尸进程，进程已终止但其父进程尚未读取其退出状态。              | 僵尸进程占用进程表项，但不占用其他资源。它们的存在是为了让父进程读取其退出状态。                                                |
| **X (Dead)**                         | 进程已终止。                                 | 这种状态很少见，通常表示进程已经完全退出。                                                                   |
| **I (Idle)**                         | 内核线程处于空闲状态。                            | 这种状态通常只适用于内核线程，表示它们当前没有任何工作要做。                                                          |
| **W (Paging)**                       | 进程正在交换（paging）。                        | 这种状态表示进程正在等待内存分页操作完成。                                                                   |
| **L (Locked)**                       | 进程有内存锁定（paging and swapping disabled）。 | 这种状态表示进程的内存被锁定，不能被交换到磁盘。                                                                |
| **< (High-priority)**                | 高优先级进程。                                | 这种状态表示进程具有较高的优先级，通常是实时进程。                                                               |
| **N (Low-priority)**                 | 低优先级进程。                                | 这种状态表示进程具有较低的优先级。                                                                       |
| **L (Has pages locked into memory)** | 进程的部分内存被锁定在内存中。                        | 这种状态表示进程的某些内存页被锁定，不能被交换到磁盘。                                                             |
| **s (Session leader)**               | 会话领导进程。                                | 这种状态表示进程是会话的领导者，通常是一个终端会话的第一个进程。                                                        |
| **l (Multi-threaded)**               | 多线程进程。                                 | 这种状态表示进程是多线程的。                                                                          |
| **+ (Foreground process group)**     | 前台进程组。                                 | 这种状态表示进程属于前台进程组，通常与终端交互。                                                                |

## 8 小结

分析完这三个案例，再来归纳一下平均负载的理解。

平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：

* 平均负载高有可能是 CPU 密集型进程导致的；
* 平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；
* 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。
