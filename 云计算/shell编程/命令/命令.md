# 1.命令行

## 1.命令行概述

众所周知，Linux是一个主要通过命令行来进行管理系统的操作系统，即通过键盘输入指令来管理系统的相关操作，如编辑文件、启动停止服务等。这和Windows用鼠标进行可视化管理不同，通过命令行来管理系统的优点是能够十分便捷的批量、自动化管理系统。

命令行命令格式：

```bash
Command [Options] Arguments
```

很多命令选项是可选的，基础使用的时候可以不带，甚至有的命令参数都可以省略。如`bc`计算器，直接一个命令就能使用。

### 1.命令行常用快捷键

既然都使用命令行，那么要更快的提升效率就要学习一下常用的快捷键，以下列出了常用的快捷键，能够有效替身效率。

| 快捷键             | 功能说明             |
| ------------------ | -------------------- |
| 补全               |                      |
| tab                | 命令或路径的补全     |
| 移动光标           |                      |
| Ctrl+a             | 光标回到行首         |
| Ctrl+e             | 光标回到行尾         |
| 剪切、粘贴、清除   |                      |
| Ctrl+Insert        | 复制命令行内容       |
| shift+Insert       | 粘贴命令行内容       |
| Ctrl+k             | 清除光标后面的内容   |
| Ctrl+u             | 清除光标前面的内容   |
| Ctrl+c             | 终止终端或删除整行   |
| 重复执行命令快捷键 |                      |
| Ctrl+d             | 退出当前shell        |
| Ctrl+r             | 搜索历史命令         |
| Ctrl+g             | 退出历史命令搜索     |
| 控制快捷键         |                      |
| Ctrl+l             | 清除屏幕内容         |
| Ctrl+z             | 中止任务并挂起       |
| !开头命令          |                      |
| !!                 | 执行上一条命令       |
| !pw                | 执行最近以pw开头命令 |
| !num               | 执行第num条命令      |
| ESC相关            |                      |
| ESC+.              | 获取上一条命令的参数 |

## 2.命令行帮助

在Linux中，最重要的命令其实是帮助命令，因为Linux的命令之多，参数之广，一个人不可能把所有的命令选项参数都记下来，所以要活用帮助命令

### man命令

- 功能说明：用于查看命令的帮助信息

- 语法格式

  ```bash
  man 参数选项 命令
  ```

`man`命令一般不使用参数选项，以下是使用man查看帮助的内容格式

| 标题        | 功能说明                               |
| ----------- | -------------------------------------- |
| NAME        | 命令说明及介绍                         |
| SYNOPSIS    | 命令的基本使用语法                     |
| DESCRIPTION | 命令使用详细描述，以及相关参数选项说明 |
| OPTIONS     | 命令相关参数选项说明                   |
| FILES       | 程序涉及的相关文件                     |
| EXAMPLES    | 命令的使用例子                         |
| SEE ALSO    | 命令相关的信息说明                     |
| BUGS        | 命令对应缺陷问题的描述                 |
| COPYRIGHT   | 版权信息相关声明                       |
| AUTHOR      | 作者介绍                               |

### --help

`man`命令显示的参数很多也很全面，但有时我们并不需要那么全面的帮助信息，只需要快速简单的查阅使用，那么这时候就可以使用`--help`

- 功能说明：获取帮助信息

- 命令格式

  ```bash
  命令 --help
  ```

### help

在Linux中有一些特殊命令，这些命令是bash程序的内置命令，例如cd、history等，这些命令在系统目录中不存在真实的程序文件，所以要使用`help`命令来查看，如：

```bash
help cd
```



## 3.关机、重启

### shutdown

`shutdown`是一个用来安全关闭或重启Linux的命令

- 语法格式

```bash
shutdown [option] TIME [MESSAGE]
```

- 选项说明

| 选项 | 说明 |
| ---- | ---- |
| -r   | 重启 |
| -h   | 关机 |

`shutdown`命令会在使用了关机命令并附带时间参数后，禁止新用户登录，直达到达指定时间关机

```bash
# 命令可以指定现在关机
shutdown -h now
# 也可以指定1分钟之后关机
shutdown -h +1
# 也可以指定固定时间
shutdown -h 11:00
```

### 常用关机、重启命令

| 命令            |
| --------------- |
| 关机            |
| shutdown -h now |
| halt            |
| init 0          |
| poweroff        |
| 重启            |
| reboot          |
| shutdown -r now |
| init 6          |

# 2.文件和目录操作命令

## cp命令

`cp`命令相信大家都不陌生，Linux中专门用来复制文件或目录的命令，但是平时大多都只是用来进行简单的复制操作，但其实`cp`能让复制更加多样化

### 命令格式

- `cp`有三种命令格式

  - 第一种和第二种语法用于将源文件复制到目标文件或目录
  - 第三种语法用于将多个源复制到目录

  ```bash
  cp [选项] 源 目标
  cp [选项] 源 目录
  cp [选项] 源-1 源-2 源-3 源-n 目录
  ```

- `cp`命令有三种主要模式

  - **两个文件名**：如果命令包含两个文件名，那么会将第一个文件的内容复制到第二个文件。如果第二个文件不存在会先创建文件。如果已经存在则会直接覆盖且没有任何提示，复制文件时最好带上`-i`选项提示信息，有的Linux系统会自带`alias cp=cp -i`

  - **一个或多个参数**：如果命令有一个或多个参数，指定文件名，并在这些参数之后，有一个参数指定目录名，那么此命令将每个源文件复制到具有相同名称的目标目录，如果不存在则创建，存在则覆盖。但是目录需要事先存在，否则报错

  - **两个目录名**：如果命令包含两个目录名，`cp`会将原目录的所有文件复制到目标目录，通常需要`-R`选项，需要目录存在。且会把源目录整个复制到目标目录中，如果只想用源目录中的子目录和文件，可以这样操作：

    ```bash
    cp -R a/* c/
    ```

### 完全复制

相信大家在使用`cp`命令时都会发现复制过去以后文件的权限会发生变化，这是因为`cp`在创建文件时是按照系统默认的文件权限进行创建的，所以每次复制过去之后都要手动更改权限，但是其实可以把文件完全复制过去，而不用自己手动再进行操作

- `-p`：保留文件模式、所有权和时间戳

```bash
[root@localhost test]# cp -p b.txt c.txt
-rwxrwxrwx. 1 root root  8 9月  17 11:35 b.txt
-rwxrwxrwx. 1 root root  8 9月  17 11:35 c.txt
```

### 增量复制

提到增量备份，大家一定会首先想起`rsync`这个工具，但其实`cp`命令的`-u`选项也可以实现简单的增量复制

- `-u`：只有当源文件比目标文件时间新或一样时才复制

  ```bash
  [root@localhost test]# cp -u d.txt p.txt
  -rwxr-xr-x. 1 mysql mysql  2 9月  17 12:10 d.txt
  -rwxr-xr-x. 1 mysql mysql  2 9月  17 12:10 p.txt
  ```

### 软硬链接

一般来说我们都习惯用`ln`命令来生成软硬链接，但其实用`cp`命令也可以达到相同的结果。还可以使用`-a`选项复制链接

- `-l`：生成硬链接
- `-s`：生成软链接

```bash
[root@localhost test]# cp -s a.txt ccc
lrwxrwxrwx. 1 root root  5 9月  17 15:40 ccc -> a.txt
```

### 常用选项

| 选项 | 用法                                                         |
| ---- | ------------------------------------------------------------ |
| -i   | 在覆盖目标文件之前，系统首先会警告用户。如果按下y，则覆盖该文件；任何其他选项都不会复制。 |
| -n   | 告诉`cp`不要覆盖现有的文件                                   |
| -d   | 原样复制                                                     |
| -u   | 只有当源文件比目标文件时间新或相同时才复制                   |
| -p   | 保留文件模式、所有权和时间戳                                 |
| -v   | 告诉`cp`打印详细输出                                         |
| -R   | 复制目录及其所有子目录和文件                                 |
| -a   | 等同于-dpR 或--preserve=all，它会保留链接，递归复制目录，并分别保留文件权限和所有权 |
| -f   | 如果无法打开现有的目标文件，则删除它并重试（当也使用了-n选项时，此选项将被忽略 |
| -b   | 类似于--backup                                               |
| -l   | 硬链接文件，而不是复制                                       |
| -s   | 生成符号链接                                                 |



## ls命令

使用Linux的人对于`ls`命令绝对不陌生，`ls`是Linux最常用的几个命令之一，但是许多人都只会`ls`最基础的用法：列出目录中的文件和子目录，但其实`ls`命令除了这最基础的用法之外，还有其他更加强大的功能。

### 查看目录文件和子目录

- 查看目录文件和子目录是`ls`命令最基础的用法，例如：

  ```bash
  [root@localhost ~]# ls /home
  drain  mysql
  ```

- 也可以更加详细的查看文件和子目录的信息

  - `-l`：长列表格式，显示文件权限、链接数、所有者名称、所有者组、文件大小、最后修改时间和文件或目录名称

  ```bash
  [root@localhost ~]# ls -l /home
  总用量 0
  drwx------. 3 drain drain 78 9月   8 16:42 drain
  drwx------. 3 mysql mysql 78 9月  16 15:23 mysql
  ```

- 也可以使用`-h`以人类可读的方式显示文件大小

### 对文件进行排序

`ls`命令最基础的用法就是列出目录中的文件和子目录，但是其实我们还能用`ls`对文件和子目录进行排序

- `--sort`：进行排序

  ```bash
  # extension或-X:按扩展名进行排序
  # size或-S:按文件大小进行排序
  # time或-t:按修改时间进行排序
  [root@localhost ~]# ls -hl --sort=time /home
  总用量 4.0K
  -rw-r--r--. 1 root  root  182 9月  16 16:09 t.txt
  drwx------. 3 mysql mysql  78 9月  16 15:23 mysql
  drwx------. 3 drain drain  78 9月   8 16:42 drain
  ```

### 常用选项

| 选项      | 用法                                                         |
| --------- | ------------------------------------------------------------ |
| -l        | 长列表格式，显示文件权限、链接数、所有者名称、所有者组、文件大小、最后修改时间和文件或目录名称 |
| -h        | 以人类可读的格式显示文件大小                                 |
| -a        | 显示所有文件，包括隐藏文件                                   |
| -r        | 以逆序显示文件和子目录                                       |
| -t        | 按修改时间排序，最新的在上面                                 |
| -s        | 列出文件及其大小                                             |
| -i        | 列出索引号                                                   |
| --sort    | 进行排序，`--sort=time`以时间排序，`extension`以扩展名进行排序，`size`以大小进行排序 |
| -R        | 递归列出目录树                                               |
| --version | 显示版本号                                                   |



## mkdir命令

熟悉Linux的同学一定对`mkdir`这个命令不陌生，这个命令就是平时我们用来建立目录用的命令。

### 基础语法

```bash
mkdir [option] [dir_name] [dir_name1].....
```

不加任何选项时，简单的创建一个目录

### 多级目录

如果我们想创建多级目录的话，简单的使用`mkdir`命令已经不能很快的帮助我们快速达到目的了，这个时候就需要给命令加上选项

- `-p`：建立多级目录，但是不受`-m`选项影响

```bash
mkdir -p c/b/a
```

### 设置权限

Linux的创建的目录有自己默认的权限，如果想创建的目录有自己设定的权限，那么需要在目录创建之后，使用`chmod`命令手动修改，但其实`mkdir`可以直接在创建目录的时候指定权限

- `-m`：设置文件模式

```bash
mkdir -m g=rw b # 使用这种模式，u和o的模式会变成777
mkdir -m 444 b
```



## mv命令

熟悉Linux的同学一定对`mv`这个命令不陌生，这个命令就是平时我们用来移动或重命名用的命令。

### 命令格式

```bash
mv [option] source target_directory/target_name
```

- mv不仅能把文件移动到目录里，还能把目录移动到目录里
- 当`mv`的第二个参数为文件名时，代表着重命名

### 注意事项

- `mv`和`cp`命令一样都能覆盖原有文件且不会有任何提醒，所以在移动文件时最好加上`-i`选项，以免覆盖重要文件
- `-n`：不覆盖已存在的文件
- `-b`：覆盖时备份

- 或者使用以上两个参数规避风险

- `mv`命令和`cp`一样也有`-u`命令，在这里`-u`命令的意思是只移动源文件比目标文件新，或者当目标文件不存在时才移动

## tree命令

`tree`在中文中的意思是树，功能是以树状图列出指定目录下的所有内容，包括所有文件、子目录及子目录中的目录和文件。

- 语法格式

  ```bash
  tree [option] [directory]
  ```

如果命令不带任何选项和目录，那么默认会显示当前目录的目录结构。

- 常用选项

| 选项 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 显示所有目录，包括隐藏文件                                   |
| -d   | 只显示目录                                                   |
| -f   | 全部显示全路径                                               |
| -i   | 不显示树枝                                                   |
| -L   | 设置显示的层级                                               |
| -F   | 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@"," |

- 使用案例

`-f`选项有个有意思的地方，那就是如果命令后不带目录，使用`-f`选项后目录会以`.`开头，如果带了目录，那么会以后面的目录替换这个`.`

```bash
# 不带目录
[root@192 test]# tree -f
.
├── ./a.sh
├── ./dump.sh
└── ./tt
    └── ./tt/c.sh
# 带目录
[root@192 test]# tree -f $PWD
/root/test
├── /root/test/a.sh
├── /root/test/dump.sh
└── /root/test/tt
    └── /root/test/tt/c.sh
```

`-f`选项一般和`-i`选项一起使用，用来获取目录下所有完整路径

```bash
[root@192 test]# tree -fi $PWD
/root/test
/root/test/a.sh
/root/test/dump.sh
/root/test/tt
/root/test/tt/c.sh
```

也可以加上`-F`选项，用来区分文件和目录

```bash
[root@192 test]# tree -fiF $PWD
/root/test
/root/test/a.sh
/root/test/dump.sh
/root/test/tt/
/root/test/tt/c.sh
```



## xargs命令

`xargs`命令是将标准输入转换为命令行参数，默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。

**xargs命令默认执行echo命令**

为什么有了管道还需要这个命令？这是因为很多命令不支持管道，所以需要`xargs`命令来接收命令的输出来当下一个命令的参数。

命令格式：

```bash
xargs [选项]  # xargs命令一般和管道一起使用
```

- 常用参数

| 参数 | 说明                                   |
| ---- | -------------------------------------- |
| -d   | 指定分隔符                             |
| -i   | 将前面的就过用{}代替，一般是一行行传递 |
| -n   | 指定每行的最大参数量                   |

### 多行与单行输出转换

```bash
[root@192 test]# echo {1..3}|xargs
1 2 3
[root@192 test]# echo {1..3}|xargs -n 1
1
2
3

# 多行变单行
xargs < test.txt
```

### 分割字符

```bash
[root@192 test]# echo "asdasxasdhajsdxasda" |xargs -d "x"
asdas asdhajsd asda

```

### 指代变量

```bash
[root@192 test]# echo `seq 10`|xargs -i touch {}
# 因为-i参数{}指代内容是一行一行的
# 所以这条命令会创建一个"1 2 3 4 5 6 7 8 9 10"的文件
```



## find命令

find命令在Linux中常用的用于查找目录和文件，同时也可以调用其他命令执行相应的操作的命令。十分重要

- 语法格式

  ```bash
  find [path] [expression]
  # path为要查找的路径，绝对路径和相对路径都行
  # expression是要执行的操作
  ```

- 常用操作

| 参数选项               | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| -maxdepth levels       | 查找的最大目录级数                                           |
| -mtime [-n\|n\|+n]     | 按照文件的修改时间查找<br>-n：表示文件修改在n天内<br>n：表示距离现在几天<br>+n：表示文件修改在n天以前 |
| -atime                 | 按照文件的访问时间来查找                                     |
| -ctime                 | 按照文件的状态改变时间来查找                                 |
| -mmin                  |                                                              |
| -amin                  |                                                              |
| -cmin                  | 跟上面三个意思一天，但单位为分钟                             |
| -size [+-]size[cwbkMG] | 按文件大小查找，支持使用 `+` 或 `-` 表示大于或小于指定大小，单位可以是 `c`（字节）、`w`（字数）、`b`（块数）、`k`（KB）、`M`（MB）或 `G`（GB）。 |
| -name                  | 按照名字查找，仅支持*、？、[]等特殊通配符。**使用通配符时用双引号引起来，否则会报错** |
| -user                  | 按照所属者进行查找                                           |
| -group                 | 按照所属组进行查找                                           |
| -newer                 | 查找更改时间比指定文件新的文件                               |
| -path pattern          | 指定路径样式，配合-prune排除指定目录                         |
| -type                  | 按文件类型查找，可以是 `f`（普通文件）、`d`（目录）、`l`（符号链接）、s（套接字文件）等。 |
| -regex pattern         | 对路径进行正则                                               |
| -exec                  | 对匹配的文件执行shell命令                                    |
| -prune                 | 指定不在某个目录查找                                         |
| -delete                | 删除匹配文件                                                 |
| ！                     | 取反                                                         |
| -a                     | 交集                                                         |
| -o                     | 并集                                                         |

### 查找文件并删除

```bash
find . -name "1.*" -exec rm -rf {} \;
# {} 指代前面匹配的文件

find . -name "1.*" -delete
```

### 删除全部文件，但排除部分文件

```bash
find . -type f ! -name "10.txt" -exec rm -rf {} \;
# 删除全部文件，但排除10.txt

find . -type f ! \( -name "10.txt" -o -name "9.txt" \) -exec rm -rf {} \;
# 也可以用()括起来，这样就不用使用多个！取反了
# 但()在shell中有特殊意思，所以要使用转义
```

### 删除1分钟前创建大于170字节的文件

```bash
find . -size +170c -cmin +1 |xargs rm -rf {}
```

### 排除某个路径

```bash
[root@192 ~]# find . -path "./a/b" -prune -o -print
.
./.dbus
./.dbus/session-bus
./.local
./.pki
./.pki/nssdb
./.ssh
./ts
./a
./a/1.txt
./9.txt

# -o后必须接-print参数，不然会多输出一个-path匹配的路径
[root@192 ~]# find . -path "./a/b/c" -prune -o -name "1.txt" -print
./a/b/1.txt
./a/1.txt
```



## basename命令

- 显示目录或文件名

```bash
-bash-4.2# basename /root/tmp/
tmp
```



## dirname命令

- 显示文件或目录路径

```bash
-bash-4.2# dirname /root/tmp/
/root
```



## file命令

- 显示文件类型

```bash
# -b选项不输出文件名
-bash-4.2# file a
a: directory
```



## chown命令

chown命令用于改变文件或目录的用户和用户组

- 语法格式

```bash
chown [option] [owner][:group] [file]
```

- 常用选项

| 选项 | 说明                       |
| ---- | -------------------------- |
| -R   | 递归更改目录的用户和用户组 |

`chown`命令可以只修改用户或用户组

```bash
chown user file
chown :group file
chown user:group file
```



## chmod命令

chmod命令是用来改变文件或目录权限的命令，但是只有文件的属主和root用户能执行这个命令。

- 命令格式

```bash
chmod [option] [mode] [file]
```

- 常用选项

| 选项 | 说明                       |
| ---- | -------------------------- |
| -R   | 递归更改目录的用户和用户组 |

**在设置权限的时候，可以直接写权限字母，也可以用数字方式**

```bash
chmod 777 1.txt  -> chmod u+rwx,g+rwx,o+rwx 1.txt
# rwx的数字分别为421，suid，sgid，stick一样
```

- 文件的权限说明

| 可读r   | 表示具有读取/阅读文件内容的权限                              |
| ------- | ------------------------------------------------------------ |
| 可写w   | 表示具有新增、修改文件内容的权限                             |
| 可执行x | 表示具有执行文件的权限<br>1. 文件本身需要能执行<br>2. 普通用户必须要有对应的x权限才能执行，而且必须还要有r权限<br>3. root只要权限位上有x权限就能执行 |

- 目录的权限说明

| 可读r   | 表示具有浏览目录下面文件及子目录的权限<br>1. 没有x不能进到目录里，即无法cd dir<br>2. ls列表可以看到所有的文件名，不过会提示无法访问目录下的权限<br>3. 如果使用ll查看，所有的属性会带？号 |
| ------- | ------------------------------------------------------------ |
| 可写w   | 表示具有增加、删除或修改目录内文件名的权限<br>1. 增加的不是文件内容，而是创建一个新文件<br>2. 只能修改文件名，重命名文件在目录的block中<br>3. 删除文件必须有x权限 |
| 可执行x | 表示具有进入目录的权限<br>1. 没有r则无法列表<br>2. 没有w无法新建文件 |



# 3.文件过滤及内容编辑处理命令

## cat命令

cat命令能连接多个文件并且打印到屏幕输出，或者重定向到指定文件中。此命令常用来显示单个文件内容，或者将及格文件内容连接起来一起显示，还可以从标准输入中读取内容显示，常与重定向配合使用。

- 命令格式

```bash
cat [option] [file]
```

- 常用选项

| 选项 | 说明                       |
| ---- | -------------------------- |
| -n   | 对输出内容编号             |
| -b   | 跟-n类型，但忽略空白行行号 |
| -A   | 将Tab显示未^I，每行末尾加$ |

```bash
# 配合自定义分隔符批量插入文件,here document语法
cat > 1.txt << EOF
123
EOF
```



## tac命令

输出与cat输出内容相反的内容



## more与less命令

这两个命令都是一页页显示文件内容，跟cat直接显示整个文件内容不一样。

- 命令格式

```bash
more/less [option] [file]
```

- 参数选项

| 参数选项 | 说明              |
| -------- | ----------------- |
| +num     | 从行号num开始显示 |

- 交互命令

| 子命令 | 解释                                   |
| ------ | -------------------------------------- |
| h/?    | 查看帮助                               |
| 空格   | 向下滚动一屏                           |
| 回车   | 向下显示一行                           |
| b      | 返回上一屏                             |
| v      | 调用vi编辑器                           |
| /      | 查找指定文本                           |
| =      | 输出当前行号                           |
| ：f    | 输出文件名和当前行号                   |
| -m     | less命令，显示类似more的进度百分号     |
| -e     | less命令，跟more一样显示到结尾自动退出 |
| -N     | less命令，显示行号                     |

**less命令是more命令的加强版，也是基于vi命令的，所以在less中可以使用一些vi中的快捷键，如搜索和g/G移到第一行和最后一行**



## head命令

head命令用于显示文件内容的头部，默认输出开头10行

- 命令格式

```bash
head [option] [file]
```

- 常用选项

| 选项     | 说明           |
| -------- | -------------- |
| -n<行数> | 指定显示的行数 |
| -c<字节> | 指定显示的字节 |

```bash
# 显示直到倒数第三行
head -n -3 /etc/passwd
```



## tail命令

跟head命令相反，只输出文件的尾部内容，默认输出10行。

- 命令格式与head一样
- 常用选项

| 选项       | 说明                         |
| ---------- | ---------------------------- |
| -n<行数>   | 指定显示的行数               |
| -c<字节数> | 指定显示的字节数             |
| -f         | 实时输出文件变化后追加的数据 |
| -s 秒数    | 监视文件变化的间隔秒数       |

```bash
# 从第几行到结尾
tail -n+1 /etc/passwd
```



## cut命令

`cut`命令是我们在Linux中的一个基本命令，用来从文件或标准输入中剪切某些部分，并将结果输出到标准输出。一般在数据处理和shell脚本中使用。`cut`命令有点像简化版的`awk`命令，所以一般在简单的场景下使用，复杂的场景一般使用`akw`命令

### 语法格式

```bash
cut OPTION [FILE]
cat file|cut [option]
```

- `cut`命令格式也很简单，但是注意`cut`命令特殊在不能省略**option**且必须携带输出范围，否则会报错

- `cut`的输出计数从1开始，也就是第一个字母记作1

### 指定输出的字符

`cut`命令可以指定要输出分隔字符的范围，可以使用以下参数指定：

- `-f`：使用指定的字段、字段集或字段范围进行选择。
- `-b`：使用指定的字节、字节集或字节范围进行选择。
- `-c`：使用指定的字符、字符集或字符范围进行选择。

```bash
#  a	b	c
> cut -f1 -s a.txt
a
```

- 默认使用**TAB**作为分隔符，但是可以使用`-d`指定分隔符

```bash
# a,b,c,d
> cut -d',' -f4 a.txt  # 以,为分隔符
d
```

- 默认在输出的时候会把不带分隔符的行也进行输出，如果只想输出匹配的行，可以加`-s`参数

### 反向匹配

有的时候可能我们想要的是不匹配的字符，也就是想剔除某些字符的时候，可以使用`--complement`，他会显示所选之外的所有字节、字符或字段

```bash
#  a	b	c
> cut -f1 -s --complement a.txt 
b       c
```

### 设置输出格式

`cut`中输出的分隔符是使用的输入的分隔符，如果我们想设置特定格式输出，可以使用`--output-delimiter`参数指定输出分隔符

```bash
> cut -d',' -f1-3 -s --output-delimiter=' ' a.txt 
a b c
```

### 输出范围

参数指定的**LITS**格式可以是：

- 表示从1开始的字节、字段或字符的整数N。
- 用逗号分隔的多个整数。
- 整数范围。
- 用逗号分隔的多个整数范围。

每个范围可以是：

- `N-`：从整数N（字段、字节或字符）开始到行尾。
- `N-M`：从整数N到整数M（包括）。
- `-M`：从第一个字段、字节或字符开始到指定的M个字段、字节或字符



## split命令

split可以根据指定的行或者文件大小来分割文件

- 命令格式

```bash
split	[option] [input] [prefix]
```

- 常用选项

| 选项 | 说明                           |
| ---- | ------------------------------ |
| -b   | 指定分割后文件的大小[B/K/M...] |
| -l   | 指定分割后的行                 |



paste命令

合并文件

- 命令格式

```bash
paster [option] [file]
```

| 选项 | 说明       |
| ---- | ---------- |
| -d   | 指定分隔符 |



## sort命令

sort命令对文件内容进行排序，并将排序结果输出

- 命令格式

```bash
sort [option] [file]
```

| 选项 | 说明             |
| ---- | ---------------- |
| -u   | 去除重复行       |
| -t   | 指定分隔符       |
| -k   | 指定区间排序     |
| -r   | 倒序             |
| -n   | 按照数值大小排序 |

```bash
# 指定按照以:分隔的第一个字段的第一个字符进行排序
sort -k1.1 -t":" file
```



## uniq命令

uniq命令可以输出或忽略文件中的重复行。常搭配sort使用

- 语法

```bash
uniq [option] [input]
```

| 选项 | 说明                             |
| ---- | -------------------------------- |
| -c   | 去除重复行，并计算每行出现的次数 |
| -d   | 只显示重复的行                   |
| -u   | 只显示唯一的行                   |

```bash
# 对文件排序并去重统计每行出现的次数
cat 1.txt |sort|uniq -c
```



## wc命令

wc用于统计文件的行数、单词或字节数

- 语法

```bash
wc [option] [file]
```

| 选项 | 说明             |
| ---- | ---------------- |
| -l   | 统计行数         |
| -w   | 统计单词数       |
| -m   | 统计字符数       |
| -c   | 统计字节数       |
| -L   | 打印最长行的长度 |

```bash
# 统计每一行的长度
for i in  $a;do echo $i|wc -L;done
```



## rev命令

反向输出文件内容，如果说tac是把文件输出顺序上下颠倒，那么rev命令就是把每一行内容颠倒。



## tee命令

tee命令用于将数据重定向到文件，同时提供一份重定向数据的副本作为后续命令的标准输入。

| -a   | 向文件追加而不是覆盖 |
| ---- | -------------------- |



## vi/vim命令

vi是Linux命令行界面下的文字编辑器，而vim是vi命令的增强版

- 命令格式

```bash
vim [option] file
vim [option] file +n # 打开文件置于n行
vim [option] file +/patter # 打开文件置于模式匹配位置
```

![mg-2020](D:/i/2023/11/19/w5pzjt.png)

### vi/vim 按键说明

除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。

#### 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等

| 移动光标的方法                                               |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| h 或 向左箭头键(←)                                           | 光标向左移动一个字符                                         |
| j 或 向下箭头键(↓)                                           | 光标向下移动一个字符                                         |
| k 或 向上箭头键(↑)                                           | 光标向上移动一个字符                                         |
| l 或 向右箭头键(→)                                           | 光标向右移动一个字符                                         |
| 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ |                                                              |
| [Ctrl] + [f]                                                 | 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)          |
| [Ctrl] + [b]                                                 | 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)           |
| [Ctrl] + [d]                                                 | 屏幕『向下』移动半页                                         |
| [Ctrl] + [u]                                                 | 屏幕『向上』移动半页                                         |
| [Ctrl] + [v]                                                 | 进入可视块操作                                               |
| [Ctrl] + [v] + I                                             | 会在所有可视块选中的行的相同列都进行同样插入                 |
| +                                                            | 光标移动到非空格符的下一行                                   |
| -                                                            | 光标移动到非空格符的上一行                                   |
| n<space>                                                     | 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。 |
| 0 或功能键[Home]                                             | 这是数字『 0 』：移动到这一行的最前面字符处 (常用)           |
| $ 或功能键[End]                                              | 移动到这一行的最后面字符处(常用)                             |
| H                                                            | 光标移动到这个屏幕的最上方那一行的第一个字符                 |
| M                                                            | 光标移动到这个屏幕的中央那一行的第一个字符                   |
| L                                                            | 光标移动到这个屏幕的最下方那一行的第一个字符                 |
| G                                                            | 移动到这个档案的最后一行(常用)                               |
| nG                                                           | n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) |
| gg                                                           | 移动到这个档案的第一行，相当于 1G 啊！ (常用)                |
| n<Enter>                                                     | n 为数字。光标向下移动 n 行(常用)                            |
| 搜索替换                                                     |                                                              |
| /word                                                        | 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) |
| ?word                                                        | 向光标之上寻找一个字符串名称为 word 的字符串。               |
| n                                                            | 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ |
| N                                                            | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 |
| 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ |                                                              |
| :n1,n2s/word1/word2/g                                        | n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) |
| **:1,$s/word1/word2/g** 或 **:%s/word1/word2/g**             | 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) |
| **:1,$s/word1/word2/gc** 或 **:%s/word1/word2/gc**           | 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) |
| 删除、复制与贴上                                             |                                                              |
| x, X                                                         | 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) |
| nx                                                           | n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 |
| dd                                                           | 剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。              |
| ndd                                                          | n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。 |
| d1G                                                          | 删除光标所在到第一行的所有数据                               |
| dG                                                           | 删除光标所在到最后一行的所有数据                             |
| d$                                                           | 删除游标所在处，到该行的最后一个字符                         |
| d0                                                           | 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符      |
| yy                                                           | 复制游标所在的那一行(常用)                                   |
| nyy                                                          | n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) |
| y1G                                                          | 复制游标所在行到第一行的所有数据                             |
| yG                                                           | 复制游标所在行到最后一行的所有数据                           |
| y0                                                           | 复制光标所在的那个字符到该行行首的所有数据                   |
| y$                                                           | 复制光标所在的那个字符到该行行尾的所有数据                   |
| p, P                                                         | p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) |
| J                                                            | 将光标所在行与下一行的数据结合成同一行                       |
| c                                                            | 重复删除多个数据，例如向下删除 10 行，[ 10cj ]               |
| u                                                            | 复原前一个动作。(常用)                                       |
| [Ctrl]+r                                                     | 重做上一个动作。(常用)                                       |
| 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ |                                                              |
| .                                                            | 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) |

#### 第二部分：一般模式切换到编辑模式的可用的按钮说明

| 进入输入或取代的编辑模式                                     |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| i, I                                                         | 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) |
| a, A                                                         | 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) |
| o, O                                                         | 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用) |
| r, R                                                         | 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) |
| 上面这些按键中，在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！ |                                                              |
| [Esc]                                                        | 退出编辑模式，回到一般模式中(常用)                           |

#### 第三部分：一般模式切换到指令行模式的可用的按钮说明

| 指令行的储存、离开等指令                                     |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| :w                                                           | 将编辑的数据写入硬盘档案中(常用)                             |
| :w!                                                          | 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ |
| :q                                                           | 离开 vi (常用)                                               |
| :q!                                                          | 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。    |
| 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ |                                                              |
| :wq                                                          | 储存后离开，若为 :wq! 则为强制储存后离开 (常用)              |
| ZZ                                                           | 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) |
| ZQ                                                           | 不保存，强制退出。效果等同于 **:q!**。                       |
| :w [filename]                                                | 将编辑的数据储存成另一个档案（类似另存新档）                 |
| :r [filename]                                                | 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 |
| :n1,n2 w [filename]                                          | 将 n1 到 n2 的内容储存成 filename 这个档案。                 |
| :! command                                                   | 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ |
| vim 环境的变更                                               |                                                              |
| :set nu                                                      | 显示行号，设定之后，会在每一行的前缀显示该行的行号           |
| :set nonu                                                    | 与 set nu 相反，为取消行号！                                 |



# 4.Linux信息显示与搜索文件命令

## uname命令

uname命令用于显示系统相关信息，例如内核版本、主机名、处理器类型等。

- 命令

```bash
uname [option]
```

- -a 或--all 　显示全部的信息，包括内核名称、主机名、操作系统版本、处理器类型和硬件架构等。。
- -m 或--machine 　显示处理器类型。
- **-n 或--nodename** 　显示主机名。
- **-r 或--release** 　显示内核版本号。
- -s 或--sysname 　显示操作系统名称。
- -v 　显示操作系统的版本。
- --help 　显示帮助。
- --version 　显示版本信息。
- -p 显示处理器类型（与 -m 选项相同）。



## hostname命令

hostname命令用于显示或设置系统的主机名称。

- 格式

```bash
hostname [option]
```

- -a：显示主机别名
- -i：显示主机的IP地址，该参数依赖DNS解析
- **-I**：显示主机IP地址



## stat命令

stat命令用于详细的显示文件或文件系统的状态信息

- 命令

```bash
stat [option] file
```



## du命令

du命令可以用于统计磁盘空间的使用情况，这个命令有助于我们找出那个文件过多的占用了磁盘空间

- 语法

```bash
du [option] file
```

- -a：显示目录所有文件大小，包括子目录下
- -h：转换格式
- -s：显示文件的总大小
- --exclude=<文件或目录>：跳过指定的目录或文件
- -X=FILE：从文件读取要跳过的
- --max-depth=N：显示N级子目录大小



## date命令

`date`命令显示与设置系统时间

- 格式

```bash
date [option] [+FORMAT]
```

- -d：显示自定字符串描述时间，而非当前时间
- -s：设置日期时间

```bash
# format格式
%%   输出字符 %
%a   星期几的缩写 (Sun..Sat)
%A   星期的完整名称(Sunday..Saturday)。 
%b   缩写的月份名称（例如，Jan）
%B   完整的月份名称（例如，January）
%c   本地日期和时间（例如，Thu Mar  3 23:05:25 2005）
%C   世纪，和%Y类似，但是省略后两位（例如，20）
%d   日 (01..31)
%D   日期，等价于%m/%d/%y
%e   一月中的一天，格式使用空格填充，等价于%_d
%F   完整的日期；等价于 %Y-%m-%d
%g   ISO 标准计数周的年份的最后两位数字
%G   ISO 标准计数周的年份，通常只对%V有用
%h   等价于 %b
%H   小时 (00..23)
%I   小时 (01..12)
%j   一年中的第几天 (001..366)
%k   小时，使用空格填充 ( 0..23); 等价于 %_H
%l   小时, 使用空格填充 ( 1..12); 等价于 %_I
%m   月份 (01..12)
%M   分钟 (00..59)
%n   新的一行，换行符
%N   纳秒 (000000000..999999999)
%p   用于表示当地的AM或PM，如果未知则为空白
%P   类似 %p, 但是是小写的
%r   本地的 12 小时制时间(例如 11:11:04 PM)
%R   24 小时制 的小时与分钟; 等价于 %H:%M
%s   自 1970-01-01 00:00:00 UTC 到现在的秒数
%S   秒 (00..60)
%t   插入水平制表符 tab
%T   时间; 等价于 %H:%M:%S
%u   一周中的一天 (1..7); 1 表示星期一
%U   一年中的第几周，周日作为一周的起始 (00..53)
%V   ISO 标准计数周，该方法将周一作为一周的起始 (01..53)
%w   一周中的一天（0..6），0代表星期天
%W   一年中的第几周，周一作为一周的起始（00..53）
%x   本地的日期格式（例如，12/31/99）
%X   本地的日期格式（例如，23:13:48）
%y   年份后两位数字 (00..99)
%Y   年
%z   +hhmm 格式的数值化时区格式（例如，-0400）
%:z  +hh:mm 格式的数值化时区格式（例如，-04:00）
%::z  +hh:mm:ss格式的数值化时区格式（例如，-04:00:00）
%:::z  数值化时区格式，相比上一个格式增加':'以显示必要的精度（例如，-04，+05:30）
%Z  时区缩写 （如 EDT）
```

```bash
-bash-4.2# date +%F -d "-1day" # 昨天日期
2023-12-14
-bash-4.2# date +%F -d "1year" # 显示一年后的命令
2024-12-15
# +表示未来；-表示过去；day表示日，month表示月；year表示年；min表示分；hour表示时

# 设置日期,可以两部分单独设置
date -s "00:00:00 2017-10-13"
```



## echo命令

echo命令将指定的文本显示在Linux命令行上

- 格式

```bash
echo [option] [string]
```

- -n：不要自动换行
- -E：不解析转移字符(默认)
- -e：格式化输出

```bash
-bash-4.2# echo -e '\033[31m 红色字 \033[0m'
 红色字
-bash-4.2# echo -e '\033[32m 绿色字 \033[0m'
 绿色字
```



## watch命令

watch命令可以以全屏的方式动态显示命令或程序的执行情况

- -n：命令执行的间隔时间，默认为2s
- -d：高亮显示命令结果的变动之处



## which命令

which命令显示命令的全路径，但查找范围只有PATH环境变量的路径

- 格式

```bash
which [option] command
```

- -a：显示全部匹配项；默认匹配到一个就停止了



# 5.文件备份和压缩命令

## tar命令

tar命令将多个文件打包在一起，并且能实现解压打包的文件的命令。

- 语法

```bash
tar [option] file....
```

- z：通过gzip压缩或解压
- c：创建新的tar包
- v：显示详细的tar命令执行过程
- f：指定压缩文件的名字
- t：不解压查看压缩包内容
- p：保存文件原有属性
- P：以绝对路径打包
- j：以bzip2命令压缩或解压
- x：解开tar包
- C：指定解压的目录路径
- --exclude=PATTERN：排除。打包路径形式和排除路径形式应保持一致
- -X：文件形式排除
- -N 日期：打包比指定日期新的文件
- -h：打包软链接

```bash
tar -zcvf 1.tar.gz 1.txt 10.txt 2.txt
tar -ztvf 1.tar.gz
-rw-r--r-- root/root        21 2023-12-12 14:37 1.txt
-rwxr-xr-x root/root        68 2023-12-01 15:52 10.txt
-rw-r--r-- root/root        23 2023-12-12 16:18 2.txt
```



## gzip命令

gzip能压缩文件，但不能压缩目录，且gzip会在源文件上直接压缩

- 格式

```bash
gzip [option] file...
```

- -d：解开压缩文件
- -v：显示过程
- -l：列出压缩文件内容
- -c：将内容输出到标准输出，不改变原文件
- -r：将目录下所有文件压缩
- -数字<0-9>：指定压缩等级，越大文件越小
- -t：测试压缩文件是否完整

很多时候我们如果想要查看已经被压缩的文件的内容，往往需要先解压，这会很麻烦，但gzip套件其实提供了一系列不需要解压就能处理压缩文件的命令`zcat`/`zgrep`/`zless`/`zdiff`，分别对应的是cat、grep、less、diff。

```bash
# 不解压直接查看压缩文件内容
zcat 1.gz
```



## zip命令

zip压缩格式是Windows和Linux等多平台通用的格式。它不会在源文件上进行压缩，且可以压缩目录。

- 格式

```bash
zip [option] zipname file
```

| 参数 | 说明               |
| ---- | ------------------ |
| -r   | 递归压缩           |
| -x   | 压缩时排除某个文件 |
| -q   | 静默输出           |

## unzip命令

解压zip格式压缩文件的命令

- 格式

```bash
unzip [option] file
```

| 参数 | 说明               |
| ---- | ------------------ |
| -l   | 查看压缩包内容     |
| -d   | 指定解压目录       |
| -v   | 解压时显示详细信息 |



## scp命令

scp命令用于在不同的主机之间复制文件，它采用SSH协议来保证复制的安全性，scp命令每次复制都是全量复制，适合于第一次复制。

- 语法

```bash
# 默认传输到root
scp [option] srcuser@host:path descuser@host:path
```

| 参数     | 说明               |
| -------- | ------------------ |
| -C       | 压缩传输           |
| -P  port | 指定端口           |
| -p       | 复制后保持原有属性 |
| -r       | 递归复制整个目录   |

```bash
# 结尾不带/会复制文件
scp -r test 192.168.2.55:/root/txt/
# 带/会复制文件夹里的内容
scp -r test/ 192.168.2.55:/root/txt/
# 复制软链接时会转换为源文件
```



## rsync命令

rsync是一款开源、快速、多功能、可实现增量的本地或远程数据镜像同步备份工具。适用于多平台。

- 格式

```bash
rsync [option] src dest
```

| 选项                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| -v                  | 详细模式输出                                                 |
| -z                  | 传输时进行压缩以提高传输效率，--compress-level=NUM可以指定压缩级别 |
| -a                  | 以递归方式传输文件，且保持所有文件属性                       |
| -r                  | 递归传输                                                     |
| -l                  | 保留软链接                                                   |
| -n                  | 测试选项，模拟执行                                           |
| --exclude=PATTERN   | 指定排除不需要传输的文件列表                                 |
| --exclude-from=FILE | 从文本文件读取需要排除的文件列表                             |
| --delete            | 使目标目录内容和源目录保持一致，删除不同的文件               |
| --include           | 指定必须同步的文件，与--exclude搭配使用                      |
| --link-dest         | 用来指定基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。 |
|                     | 具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。 |

```bash
# 删除目标test目录下与源目录test下不一样的文件
# 如果目标目录不存在会自动创建
[root@192 test]# rsync -avz --delete ../test/ root@192.168.2.55:/root/txt/test/
```



# 6.用户管理命令

## useradd命令

`useradd`命令一般用来创建新的用户或修改用户的信息。

- 语法格式

```bash
useradd [options] usernam
```

- 常用选项

| 选项 | 说明                            |
| ---- | ------------------------------- |
| -c   | 添加用户的说明(passwd文件第5列) |
| -d   | 设置用户家目录                  |
| -e   | 设置用户终止日期：YYYY-MM-DD    |
| -f   | 用户过期多少天后永久停权        |
| -g   | 指定用户对应用户组              |
| -G   | 指定附加组                      |
| -r   | 建立系统账号                    |
| -u   | 指定用户uid                     |
| -s   | 指定用户登录所用shell           |
| -n   | 不创建同名用户组                |
| -M   | 不建立用户家目录                |
| -m   | 家目录不存在自动创建            |

### 修改并创建系统用户所在家目录

```bash
-bash-4.2# useradd -r  test2 -md  /root/tt7
```

**如果不加参数，用户创建会按照/etc/default/useradd文件中定义的创建**

## usermod命令

`usermod`命令一般用来修改已存在用户的账户信息

- 语法格式

```bash
usermod [options] username
```

- 常用选项

| 选项 | 说明                            |
| ---- | ------------------------------- |
| -c   | 修改用户的说明(passwd文件第5列) |
| -d   | 修改用户家目录                  |
| -e   |                                 |
| -f   |                                 |
| -g   |                                 |
| -G   |                                 |
| -s   |                                 |
| -u   | 参数与useradd含义一样           |
| -a   | 追加，仅与-G一起用              |

### 向用户追加附加组

```bash
# 如果只使用-G的话，只会进行修改附加组
-bash-4.2# usermod test -aG drain,mysql
```



## userdel命令

`userdel`命令用来删除用户

- 命令格式

```bash
userdel [options] username
```

- 常用选项

| 选项 | 说明                                       |
| ---- | ------------------------------------------ |
| -f   | 强制删除用户，即使已经登录                 |
| -r   | 删除用户和家目录，如果不加仅仅只是删除用户 |



## passwd命令

`passwd`命令用来修改用户密码及密码过期时间等。因为`passwd`命令具有`suid`权限，所以不管是超级用户还是普通用户都能使用它。但普通用户只能修改自己的密码。

且普通用户在修改密码的时候如果不符合系统密码规则，则修改无效。只有超级用户能无视系统密码规则。

- 命令格式

```bash
passwd [option] username
```

- 常用选项

| 选项    | 说明               |
| ------- | ------------------ |
| --stdin | 从标准输入读取密码 |
|-d |删除密码|
|-f |强迫用户下次登录时必须修改口令|
|-w |口令要到期提前警告的天数|
|-k |更新只能发送在过期之后|
|-l |停止账号使用|
|-S |显示密码信息|
|-u |启用已被停止的账户|
|-x |指定口令最长存活期|
|-g| 修改群组密码|

### 从输入读取密码

```bash
# 修改drain用户密码为jkasjd
[root@192 root]# echo "jkasjd"|passwd --stdin drain
```



## su命令

su命令用于将当前用户切换到指定用户或者以指定用户身份执行命令或程序

- 语法

```bash
su [option] [user]
# 若省略用户名，则切换为root用户
# root切换到普通用户不需要密码，但反之需要
```

| 选项         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| -,-l,--login | 切换用户时，将用户的家目录、系统环境变量等重新按切换后的用户初始化 |
| -c           | 向shell传递单个命令                                          |

## visudo命令

visudu命令是专门用来编辑/etc/sudoers这个文件的，同时提供语法检查等功能。/etc/sudoers是sudo命令的配置文件

- 语法

```bash
viduso [option]
```

| -c   | 手动执行语法检查 |
| ---- | ---------------- |

```bash
# sudoers配置格式
user MACHEINE=（privuser） command
%group MACHEINE=（privuser） command

# user用户可以在所有机器上拥有所有用户权限，可以执行所有命令
user ALL=(ALL) ALL
# 命令只用绝对路径
drain ALL=(ALL) /usr/bin/cat /etc/passwd, /usr/bin/useradd
# 执行命令总要输入drain的密码，可以使用NOPASSWD免密码
drain ALL=(ALL) NOPASSWD:/usr/bin/cat /etc/passwd, /usr/bin/useradd
```

## sudo命令

sudo命令可以让普通用户在执行指定的命令或程序上，拥有超级用户的权限，通过分类针对性的将不用的命令授予指定的普通用户，同时普通用户不需要root用户就可以得到授权

- 语法

```bash
sudo [option]
```

- -V 显示版本编号
- -h 会显示版本编号及指令的使用方式说明
- -l 显示出自己（执行 sudo 的使用者）的权限
- -v 因为 sudo 在第一次执行时或是在 N 分钟内没有执行（N 预设为五）会问密码，这个参数是重新做一次确认，如果超过 N 分钟，也会问密码
- -k 将会强迫使用者在下一次执行 sudo 时问密码（不论有没有超过 N 分钟）
- -b 将要执行的指令放在背景执行
- -p prompt 可以更改问密码的提示语，其中 %u 会代换为使用者的帐号名称， %h 会显示主机名称
- -u username/#uid 不加此参数，代表要以 root 的身份执行指令，而加了此参数，可以以 username 的身份执行指令（#uid 为该 username 的使用者号码）
- -s 执行环境变数中的 SHELL 所指定的 shell ，或是 /etc/passwd 里所指定的 shell
- -H 将环境变数中的 HOME （家目录）指定为要变更身份的使用者家目录（如不加 -u 参数就是系统管理者 root ）



## id命令

id命令能够显示指定用户真实有效的用户ID和组ID等信息

- 语法

```bash
id [option] [username]
```

| 参数 | 说明                 |
| ---- | -------------------- |
| -g   | 显示用户组ID         |
| -G   | 显示附加组ID         |
| -n   | 显示名称，不显示数字 |
| -r   | 显示实际ID           |
| -u   | 显示用户ID           |



## w命令

w命令显示已经登录系统的用户，并显示用户正在执行的命令

- 语法

```bash
w [option] [user]
```

| 参数 | 说明                                |
| ---- | ----------------------------------- |
| -h   | 不显示前两行标题信息                |
| -u   | 忽略执行程序的名称，以及CPU时间信息 |
| -s   | 使用短输出格式                      |

```bash
[root@192 ~]# w
 16:04:58 up 9 min,  1 user,  load average: 0.00, 0.04, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.2.87     16:04    2.00s  0.04s  0.00s head -5
```



## who命令

who命令能够显示已经登录系统的用户，以及系统的启动时间等信息

- 语法

```bash
who [option]
```

| 选项 | 说明                 |
| ---- | -------------------- |
| -a   | 显示所有信息         |
| -b   | 显示系统启动时间     |
| -d   | 显示已死进程         |
| -H   | 显示标题，默认不显示 |
| -l   | 显示登录进程         |



## whoami

用于显示当前登录的用户名



## last命令

last命令能够从日志文件/var/log/wtmp读取信息并显示用户最近的登录列表

- 语法

```bash
last [option]
```

| -num<br>-n num | 指定显示结果的行数 |
| -------------- | ------------------ |

## lastb命令

lastb命令可以从日志文件/var/log/btmp中读取信息，并显示用户登录失败的记录，用于系统登录异常
```bash
lastb [option]
```

| -num<br>-n num | 指定显示结果的行数 |
| -------------- | ------------------ |

## lastlog命令

lastlog命令从日志文件var/log/lastlob中读取信息，并显示所有用户的最近登录记录，用于查看系统是否有异常登录



# 7.进程管理命令

pstree命令以树形结构显示进程和进程之间的关系

- 语法

```bash
pstree [option] [<PID>/<user>]
# 如果不指定<PID>/<user>，那就列出所有的进程
```

| 参数 | 选项                                    |
| ---- | --------------------------------------- |
| -a   | 显示每个进程对应的完整指令              |
| -c   | 显示进程包括父进程和子进程              |
| -h   | 对正在执行的程序进行特别标准            |
| -n   | 根据进程PID来排序输出，默认是以名称输出 |
| -p   | 显示进程的PID                           |
| -u   | 显示进程对应的用户名称                  |



## pgrep命令

pgrep可以查找匹配条件的进程号

| -u   | 显示指定用户的所有进程号 |
| ---- | ------------------------ |



## kill命令

kill命令能终止进程

- 语法

```bash
kill [option] [pid]
```

| 参数 | 说明               |
| ---- | ------------------ |
| -l   | 列出全部的信号名称 |
| -s   | 指定要发送的信号   |

- 常用信号

| 信号     | 说明                               |
| -------- | ---------------------------------- |
| HUP(1)   | 挂起，通常因终端掉线或用户退出引发 |
| INT(2)   | 中断，通常是按下ctrl+c发出         |
| QUIT(3)  | 退出，通常是按下ctrl+\发出         |
| KILL(9)  | 立即结束进程的运行                 |
| TERM(15) | 终止，通常在系统关机时发送         |
| TSTP(20) | 暂停进程的运行，通常是ctrl+z发出   |

**Linux中有一个特殊的信号0，表示不发送任何信号给进行，但能检查进程是否存在**

```bash
[root@192 ~]# kill -0 0
[root@192 ~]# echo $?
0
[root@192 ~]# kill -0 321321
[root@192 ~]# echo $?
1
```



## pkill命令

pkill命令可通过进程名终止指定的进程。使用killall终止进程需要连续执行几次，因为killall只会杀死父进程，但pkill会杀死指定进程及所有子进程

- 语法

```bash
pkill [option] name
```

| 选项    | 参数               |
| ------- | ------------------ |
| -t 终端 | 杀死指定终端的进程 |
| -u 用户 | 杀死指定用户的进程 |



## strace命令

strace命令时Linux环境下的一款程序调试工具，用于检查一个应用程序所使用的系统调用以及它所接收的系统信息。strace会追踪程序运行时的整个生命周期，输出每一个系统调用的每次、参数、返回值和执行所消耗的时间等。

- 语法

```bash
strace [option] command
```



## runlevel命令

输出当前系统运行级别

- 0：停机
- 1：单用户模式
- 2：无网络的多用户模式
- 3：多用户模式
- 4：未使用
- 5：图像界面多用户模式
- 6：重启



## nice/renice命令

nice/renice命令用来调整进程优先级的，renice是给正在运行的进程调整优先级的。只有root用户能减低优先级，普通用户只能增加，且优先级范围为0-19.

```bash
[root@192 ~]# nice  # 输出默认优先级
0  
# 默认nice命令给进程优先级增加10，-n调增到增加5
nice -n 5 your_command

#-n priority：指定 nice 值。这个值的范围通常是 -20 到 19，-20 表示最高优先级，19 表示最低优先级。
#-p pid, ...：指定一个或多个进程的进程号，对这些进程进行 nice 调整。
#-g pgrp, ...：指定一个或多个进程组的进程组号，对这些进程组的所有成员进行 nice 调整。
#-u user, ...：指定一个或多个用户的用户名，对这些用户的所有进程进行 nice 调整。
# 调整到10
renice 10 -p 12345
```

```bash
[root@192 ~]# ps -l # 查看优先级
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S     0 1642393 1642392  0  80   0 -  7143 -      pts/0    00:00:00 bash
0 R     0 1678312 1642393  0  80   0 - 11423 -      pts/0    00:00:00 ps
# PRI是进程实际的优先级，而NI是用户层面的概念
# PRI=80(系统默认大小)+nice
```



## timeout命令

**timeout 指定运行的命令最大运行时长，时间到则终止该命令。**

```bash
# 最多执行5s，5s后发送SIGTERM信号
[root@192 ~]# timeout 5s ls
# 如果5s后进程没有结束，会在9s时发送SIGKILL信号
[root@192 ~]# time timeout -k 5s 9s sleep 50
# 指定发送的信号，可以是数字
timeout -s SIGKILL 5s ping www.baidu.com
```



## top命令

top命令用于实时的对系统处理器状态进行监控，它能够实时的显示系统中各个进程的资源占用情况。

- 语法

```bash
top [option]
```

- 选项

```bash
-b：以批处理模式操作；
-c：显示完整的治命令；
-d：屏幕刷新间隔时间；
-I：忽略失效过程；
-s：保密模式；
-S：累积模式；
-i：不显示闲置或僵死进程；
-u<用户名>：指定用户名；
-p<进程号>：指定进程；
-n<次数>：循环显示的次数；
-H：所有线程占用资源情况。
```

- 交互命令

```test
h：显示帮助画面，给出一些简短的命令总结说明；
k：终止一个进程；
i：忽略闲置和僵死进程，这是一个开关式命令；
q：退出程序；
r：重新安排一个进程的优先级别；
S：切换到累计模式；
s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；
f或者F：从当前显示中添加或者删除项目；
o或者O：改变显示项目的顺序；
l：切换显示平均负载和启动时间信息；
m：切换显示内存信息；
t：切换显示进程和CPU状态信息；
c：切换显示命令名称和完整命令行；
M：根据驻留内存大小进行排序；
P：根据CPU使用百分比大小进行排序；
T：根据时间/累计时间进行排序；
w：将当前设置写入~/.toprc文件中。
```

第一行：`top - 16:20:38 up 12 days, 5:24, 2 users, load average: 0.04, 0.03, 0.05`

- `top - 16:20:38`：表示当前的时间是16:20:38。
- `up 12 days, 5:24`：表示系统已经运行了12天5小时24分钟。
- `2 users`：表示当前有2个用户登录系统。
- `load average: 0.04, 0.03, 0.05`：表示系统的平均负载，即任务队列的平均长度。三个数值分别为1分钟、5分钟、15分钟前到现在的平均值。一般来说，这个数值不应该超过CPU的核数，否则可能会导致系统性能下降。

第二行：`Tasks: 127 total, 1 running, 126 sleeping, 0 stopped, 0 zombie`

- `Tasks: 127 total`：表示当前系统有127个进程。
- `1 running`：表示当前有1个进程处于运行状态。
- `126 sleeping`：表示当前有126个进程处于休眠状态。
- `0 stopped`：表示当前没有进程处于停止状态。
- `0 zombie`：表示当前没有进程处于僵尸状态。

第三行：`%Cpu(s): 0.3 us, 0.7 sy, 0.0 ni, 99.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st`

- `%Cpu(s):`：表示CPU的使用率，括号中的s表示单个CPU，如果是多核CPU，可以用数字键1切换显示每个核心的使用率。
- `0.3 us`：表示用户空间占用CPU的百分比，即用户运行的程序所占用的CPU时间。
- `0.7 sy`：表示内核空间占用CPU的百分比，即系统内核处理的任务所占用的CPU时间。
- `0.0 ni`：表示用户进程改变过优先级所占用的CPU时间，即通过nice命令调整过的进程所占用的CPU时间。
- `99.0 id`：表示CPU的空闲百分比，即没有被任何进程使用的CPU时间。
- `0.0 wa`：表示等待输入输出的CPU时间百分比，即CPU在等待磁盘或网络操作完成的时间。
- `0.0 hi`：表示硬中断占用的CPU时间百分比，即CPU处理硬件设备发出的中断请求的时间。
- `0.0 si`：表示软中断占用的CPU时间百分比，即CPU处理软件程序发出的中断请求的时间。
- `0.0 st`：表示虚拟机偷取的CPU时间百分比，即如果系统运行在虚拟机中，被其他虚拟机占用的CPU时间。

第四行：`KiB Mem : 1863012 total, 1286408 free, 216532 used, 360072 buff/cache`

- `KiB Mem :`：表示物理内存的信息，单位为KB。
- `1863012 total`：表示物理内存的总量。
- `1286408 free`：表示空闲的物理内存量。
- `216532 used`：表示已经使用的物理内存量。
- `360072 buff/cache`：表示用作内核缓存的物理内存量，包括缓冲区（buffer）和缓存（cache）。

第五行：`KiB Swap: 5242876 total, 7999484 free, 0 used. 1468240 avail Mem`

- `KiB Swap:`：表示交换区的信息，单位为KB。
- `5242876 total`：表示交换区的总量。
- `7999484 free`：表示空闲的交换区量。
- `0 used`：表示已经使用的交换区量。
- `1468240 avail Mem`：表示可用的物理内存量，即空闲内存加上可回收的缓存。

**第二部分：各个进程的详细信息**

第八行：`PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND`

- `PID`：表示进程的标识符，是一个唯一的数字。
- `USER`：表示进程的所有者，是一个用户名。
- `PR`：表示进程的优先级，是一个数字，越小表示优先级越高。
- `NI`：表示进程的nice值，是一个数字，可以通过nice命令调整，负值表示高优先级，正值表示低优先级。
- `VIRT`：表示进程使用的虚拟内存总量，单位为KB，包括交换区和物理内存。
- `RES`：表示进程使用的未被换出的物理内存量，单位为KB，包括代码段和数据段。
- `SHR`：表示进程共享的内存量，单位为KB，包括共享库和共享内存等。
- `S`：表示进程的状态，是一个字母，有以下几种可能：
  - `D`：表示不可中断的睡眠状态，通常是在等待IO操作。
  - `R`：表示运行状态，通常是在CPU的运行队列中。
  - `S`：表示可中断的睡眠状态，通常是在等待某个事件发生。
  - `T`：表示停止状态，通常是被信号或调试器停止。
  - `Z`：表示僵尸状态，通常是子进程结束后，父进程还没有回收它的资源。
- `%CPU`：表示进程占用的CPU时间百分比，是从上次刷新到现在的时间间隔内的平均值。
- `%MEM`：表示进程占用的物理内存百分比，是根据RES计算的。
- `TIME+`：表示进程占用的CPU时间总和，单位为分:秒.百分秒，例如1:23.45表示1分23秒450毫秒。
- `COMMAND`：表示进程的命令名或命令行，如果太长会被截断，可以用-c选项显示完整的命令行。



## strace命令

`strace`是一个在Linux系统上常用的系统调用跟踪工具。它允许你监视一个进程的系统调用，信号和进程间的通信。通过跟踪系统调用，你可以了解程序的行为、性能瓶颈以及可能的问题。

以下是`strace`的一些基本用法：

```bash
bashCopy code
strace [options] command [arguments]
```

其中，`command`是要跟踪的程序，而`arguments`是该程序的参数。

下面是一个简单的例子，演示如何使用`strace`来跟踪一个简单的命令：

```bash
bashCopy code
strace ls
```

这将输出`ls`命令执行时的所有系统调用。你可以看到文件的打开、关闭、读取等操作。

你还可以将输出保存到文件，以便稍后分析：

```bash
bashCopy code
strace -o output.txt ls
```

`-o`选项允许将输出重定向到指定的文件。

以下是一些常用的`strace`选项：

- `-c`：以汇总统计信息的形式输出结果。
- `-f`：跟踪由`fork`产生的子进程。
- `-p PID`：附加到指定PID的进程上进行跟踪。
- `-e trace=...`：指定要跟踪的系统调用，可以使用逗号分隔的列表。

例如，要跟踪一个进程及其子进程的所有系统调用，可以使用以下命令：

```bash
bashCopy code
strace -f command
```



# 8.网络管理命令

## route命令

route命令可以显示或管理Linux系统的路由表，route命令设置的路由主要是静态路由。

| 选项       | 说明                                      |
| ---------- | ----------------------------------------- |
| -n         | 直接使用IP地址，不进行DNS解析主机名       |
| add        | 添加路由信息                              |
| del        | 删除路由信息                              |
| target     | 指定目标网络或主机，可以是IP或主机/网络名 |
| -net       | 到一个网络的路由，后面接一个网络号地址    |
| -host      | 到一个主机的路由，后面接一个主机地址      |
| netmask NM | 为添加的路由指定网络掩码                  |
| gw GW      | 为发往目标网络/主机的任何分组指定网关     |
| dev if     | 指定由那个网络设备出去，接网络设备名      |

```bash
[root@192 ~]# route 
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         router.ctc      0.0.0.0         UG    100    0        0 ens160
192.168.2.0     0.0.0.0         255.255.255.0   U     100    0        0 ens160
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0

# Destination：网络地址
# Gateway：网关
# Genmask：表示子网掩码
# Flags：
#  U：表示此路由为启动状态
#  H：目标路由是一个主机而非网络
#  R：使用动态路由时，恢复路由信息标识
#  G：表示需要使用外部的主机来转接传递数据
#  M：表示路由被修改
#  D：已经由服务设定为动态路由
#  !：这个路由不会被接受
# Metric：需要经过几个网络节点才能到达路由的目标网络地址
# Ref：参考到此路由规则的数目
# Use：有几个转送数据包参考了此路由规则
# Iface：路由对应的网络设备接口
```

```bash
[root@192 ~]# route del default gw 192.168.2.1
[root@192 ~]# route add default gw 192.168.2.1

# 可以在/etc/sysconfig/static-routes文件中写入
# 这样重启网络和重启机器都能生效
any net 192.168.2.0/24 gw 192.168.2.1
```



## arp命令

arp命令用于操作本机的arp缓存区，它可以显示arp缓存区中的所有条目、删除指定条目或添加静态的IP地址与MAC地址的对应关系

ARP是地址解析协议，主要功能是根据IP获取物理地址

| 选项 | 说明                                |
| ---- | ----------------------------------- |
| -n   | 显示数字IP                          |
| -s   | 指定主机的IP地址与MAC地址的静态映射 |
| -d   | 从arp缓存区中删除指定主机的arp条目  |
| -i   | 指定网络接口                        |
| -v   | 显示详细的arp缓存条目               |



## netstat命令

netstat命令用于显示本机网络的连接状态、运行端口和路由表等信息

| 参数      | 选项                                                         |
| --------- | ------------------------------------------------------------ |
| -r        | 显示路由表信息                                               |
| -t        | 显示所有TCP的连接情况                                        |
| -u        | 显示所有udp的连接情况                                        |
| -n        | 显示数字形式的地址而不是去解析主机、端口或用户名。默认netstat会尝试解析并显示主机的主机名，这会拖慢命令速度。 |
| -l        | 仅显示连接状态为LISTEN的服务的网络状态                       |
| -p        | 显示socket所属进程的PID和名称                                |
| -c <秒数> | 设置每隔几秒刷新一次                                         |
| -a        | 显示处于监听和非监听状态的socket信息                         |

常用选项组合：

- tunlp：显示tcp和udp正在监听的连接信息
- an：显示所有的连接信息

## ss命令

ss命令与netstat命令类似，但比netstat能显示更多信息，而且比netstat更快更高效，但有的系统可以没有ss命令，需要安装iproute包。

| 参数 | 选项                                               |
| ---- | -------------------------------------------------- |
| -s   | 显示socket使用统计                                 |
| -t   | 显示所有TCP的连接情况                              |
| -u   | 显示所有udp的连接情况                              |
| -n   | 显示数字形式的地址而不是去解析主机、端口或用户名。 |
| -l   | 仅显示连接状态为LISTEN的服务的网络状态             |
| -p   | 显示socket所属进程的PID和名称                      |
| -a   | 显示处于监听和非监听状态的socket信息               |

常用选项组合：

- tunlp
- an
- s



## ping命令

ping命令可以用于测试主机之间网络的连通性。执行ping命令会使用ICMP传输协议。

- 语法

```bash
ping [option] destination
```

| 选项        | 说明                                       |
| ----------- | ------------------------------------------ |
| -c <次数>   | 指定发送ICMP报文的次数，否则会一直发送报文 |
| -i <间隔>   | 指定时间间隔，默认1s                       |
| -t <生存期> | 指定发送包的生存期TTL                      |

```bash
rtt min/avg/max/mdev = 0.242/0.250/0.256/0.005 ms
# ping返回的rtt(传输的时间延迟)，可以作为衡量网络延迟的参数
```



## traceroute命令

这个命令用于显示网络数据包传输到指定主机的路径信息，追踪数据传输路由状况。默认数据包大小是60字节(IPV4)或80字节(IPV6)。有的系统可能没有这个命令，需要安装

- 语法

```bash
traceroute [option] [host] [paclet_len]
```

| 参数     | 说明                            |
| -------- | ------------------------------- |
| -q <num> | 设置每一跳的探测包数量，默认是3 |
| -I       | 使用ping监测，默认是使用UDP协议 |
| -n       | 直接使用IP地址                  |
| -m       | 设置最大跳数                    |



## wget命令

**wget命令** 用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。

用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。wget虽然功能强大，但是使用起来还是比较简单：

1. **支持断点下传功能** 
2. **同时支持FTP和HTTP下载方式** 
3. **支持代理服务器** 对安全强度很高的系统而言，一般不会将自己的系统直接暴露在互联网上，所以，支持代理是下载软件必须有的功能；

- 语法

```shell
wget [参数] [URL地址]
```

- 选项

```
-b, –-background 启动后转入后台执行
-O –-output-document=FILE 把文档写到FILE文件中
-q, –-quiet 安静模式(没有输出)
-c, –-continue 接着下载没下载完的文件
-T, –-timeout=SECONDS 设定响应超时的秒数
--limit-rate=300k 限速下载
-i, –-input-file=FILE 下载在FILE文件中出现的URLs
--tries  设置重试次数，默认为20次
--spider 不进行下载，用来测试URL
```

```shell
# 伪装代理
wget --user-agent="Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16" http://www.jsdig.com/testfile.zip

```



## nslookup命令

**nslookup命令** 是常用域名查询工具，就是查DNS信息用的命令。

nslookup有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。

在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息，此时也可以指定查询的DNS服务器。

进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即`/etc/resolv.conf`的第一个dns地址）。或者输入`nslookup -nameserver/ip`。进入非交互模式，就直接输入`nslookup 域名`就可以了。

```shell
nslookup(选项)(参数)(DNS服务器) # nslookup www.sustech.edu.cn 8.8.8.8
```



## dig命令

**dig命令** 是常用的域名查询工具，可以用来测试域名系统工作是否正常。

- 语法

```shell
dig(选项)(参数)
```

- 选项

```
@<服务器地址>：指定进行域名解析的域名服务器；
-b<ip地址>：当主机具有多个IP地址，指定使用本机的哪个IP地址向域名服务器发送域名查询请求；
-f<文件名称>：指定dig以批处理的方式运行，指定的文件中保存着需要批处理查询的DNS任务信息；
-P：指定域名服务器所使用端口号；
-t<类型>：指定要查询的DNS数据类型，如A、MX等，默认是A；
-x<IP地址>：执行逆向域名查询；
-4：使用IPv4；
-6：使用IPv6；
-h：显示指令帮助信息；
+trace：从根域开始跟踪查询结果；
+short：仅输出CNAME信息和A记录；
+nocmd：不输出dig版本信息
+nocomment：不输出详情注释信息
+nostat：不输出最后的统计信息
```

```bash
[root@192 ~]# dig www.baidu.com +nocomment +nocmd +nostat 
;www.baidu.com.                 IN      A
www.baidu.com.          600     IN      CNAME   www.a.shifen.com.
www.a.shifen.com.       600     IN      A       180.101.50.242
www.a.shifen.com.       600     IN      A       180.101.50.188
```



## tcpdump命令

**tcpdump命令** 是一款抓包，嗅探器工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用`-w`选项将数据包保存到文件中，方便以后分析。

- 语法

```shell
tcpdump [option] [expression]
```

- 选项

```
-a：尝试将网络和广播地址转换成名称；
-c<数据包数目>：收到指定的数据包数目后，就停止进行倾倒操作；
-d：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出；
-dd：把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出；
-ddd：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出；
-e：每行的打印输出中将包括数据包的数据链路层头部信息；
-f：用数字显示网际网络地址；
-F<表达文件>：指定内含表达方式的文件；
-i<网络接口>：指定要监听数据包的网络接口；
-l：使用标准输出列的缓冲区；
-n：不进行DNS解析为域名；
-nn：不将协议和端口数字等转换成名字；
-N：不列出域名；
-O：不将数据包编码最佳化；
-p：不让网络界面进入混杂模式；
-q ：快速输出，仅列出少数的传输协议信息；
-r<数据包文件>：从指定的文件读取数据包数据；
-s<数据包大小>：设置每个数据包的大小；
-S：用绝对而非相对数值列出TCP关联数；
-t：在每列倾倒资料上不显示时间戳记；
-tt： 在每列倾倒资料上显示未经格式化的时间戳记；
-tttt：显示以标准日期格式显示时间戳；
-T<数据包类型>：强制将表达方式所指定的数据包转译成设置的数据包类型；
-v：详细显示指令执行过程，最多三个v；
-x：用十六进制字码列出数据包资料；
-w<数据包文件>：把数据包数据写入指定的文件。

host host：指定要过滤的主机，可以是IP地址或域名，表示只显示与该主机相关的数据包。
src host host：指定要过滤的源主机，表示只显示从该主机发出的数据包。
dst host host：指定要过滤的目的主机，表示只显示发往该主机的数据包。
net net：指定要过滤的网络，可以是IP地址或域名，表示只显示与该网络相关的数据包。
src net net：指定要过滤的源网络，表示只显示从该网络发出的数据包。
dst net net：指定要过滤的目的网络，表示只显示发往该网络的数据包。
port port：指定要过滤的端口，表示只显示与该端口相关的数据包。
src port port：指定要过滤的源端口，表示只显示从该端口发出的数据包。
dst port port：指定要过滤的目的端口，表示只显示发往该端口的数据包。
proto：指定要过滤的协议，可以是tcp, udp, icmp等，表示只显示该协议的数据包。
and：指定要同时满足两个条件的数据包，比如host A and host B表示只显示与主机A和主机B都相关的数据包。
or：指定要满足任意一个条件的数据包，比如host A or host B表示只显示与主机A或主机B相关的数据包。
!：指定要排除某个条件的数据包，比如! host A表示只显示与主机A无关的数据包。
```

```shell
tcpdump -n host 192.168.2.22 and ! 192.168.2.23
```



# 9.系统管理命令

## lsof命令

**lsof命令** 用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。

在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。

- 语法

```shell
lsof [option]
```

- 选项

```
-a：列出打开文件存在的进程；
-c<进程名>：列出指定进程所打开的文件；
-g：列出GID号进程详情；
-d<文件号>：列出占用该文件号的进程；
+d<目录>：列出目录下被打开的文件；
+D<目录>：递归列出目录下被打开的文件；
-n<目录>：列出使用NFS的文件；
-i<条件>：列出符合条件的进程（协议、:端口|服务、 @ip ）
-p<进程号>：列出指定进程号所打开的文件；
-u：列出UID号进程详情；
-U：列出所有socket文件
-h：显示帮助信息；
-v：显示版本信息
```

**lsof输出各列信息的意义如下：**

| 标识      | 说明                                 |
| --------- | ------------------------------------ |
| `COMMAND` | 进程的名称                           |
| `PID`     | 进程标识符                           |
| `PPID`    | 父进程标识符（需要指定-R参数）       |
| `USER`    | 进程所有者                           |
| `PGID`    | 进程所属组                           |
| `FD`      | 文件描述符，应用程序通过它识别该文件 |

文件描述符列表：

| 标识   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| `cwd`  | 表示当前工作目录，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改 |
| `txt`  | 该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序 |
| `lnn`  | 库引用 (AIX);                                                |
| `er`   | FD 信息错误（参见名称栏）                                    |
| `jld`  | jail 目录 (FreeBSD);                                         |
| `ltx`  | 共享库文本（代码和数据）                                     |
| `mxx`  | 十六进制内存映射类型编号xx                                   |
| `m86`  | DOS合并映射文件                                              |
| `mem`  | 内存映射文件                                                 |
| `mmap` | 内存映射设备                                                 |
| `pd`   | 父目录                                                       |
| `rtd`  | 根目录                                                       |
| `tr`   | 内核跟踪文件 (OpenBSD)                                       |
| `v86`  | VP/ix 映射文件                                               |
| `0`    | 表示标准输出                                                 |
| `1`    | 表示标准输入                                                 |
| `2`    | 表示标准错误                                                 |

一般在标准输出、标准错误、标准输入后还跟着文件状态模式：

| 标识   | 说明                                      |
| ------ | ----------------------------------------- |
| `u`    | 表示该文件被打开并处于读取/写入模式       |
| `r`    | 表示该文件被打开并处于只读模式            |
| `w`    | 表示该文件被打开并处于写入模式            |
| `空格` | 表示该文件的状态模式为 unknow，且没有锁定 |
| `-`    | 表示该文件的状态模式为 unknow，且被锁定   |

同时在文件状态模式后面，还跟着相关的锁：

| 标识    | 说明                                     |
| ------- | ---------------------------------------- |
| `N`     | 对于未知类型的Solaris NFS锁              |
| `r`     | 用于部分文件的读取锁定                   |
| `R`     | 对整个文件进行读取锁定                   |
| `w`     | 对文件的一部分进行写锁定(文件的部分写锁) |
| `W`     | 对整个文件进行写锁定(整个文件的写锁)     |
| `u`     | 用于任何长度的读写锁                     |
| `U`     | 对于未知类型的锁                         |
| `x`     | 对于文件部分的SCO OpenServer Xenix锁     |
| `X`     | 对于整个文件的SCO OpenServer Xenix锁     |
| `space` | 如果没有锁                               |

**文件类型**

| 标识     | 说明                           |
| -------- | ------------------------------ |
| `DIR`    | 表示目录                       |
| `CHR`    | 表示字符类型                   |
| `BLK`    | 块设备类型                     |
| `UNIX`   | UNIX 域套接字                  |
| `FIFO`   | 先进先出 (FIFO) 队列           |
| `IPv4`   | 网际协议 (IP) 套接字           |
| `DEVICE` | 指定磁盘的名称                 |
| `SIZE`   | 文件的大小                     |
| `NODE`   | 索引节点（文件在磁盘上的标识） |
| `NAME`   | 打开文件的确切名称             |
| `REG`    | 常规文件                       |



## uptime命令

**uptime命令** 能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。

- 语法

```shell
uptime
```



## free命令

**free命令** 可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。

- 语法

```bash
free [option]
```

- 选项

```
-b # 以Byte为单位显示内存使用情况；
-k # 以KB为单位显示内存使用情况；
-m # 以MB为单位显示内存使用情况；
-g # 以GB为单位显示内存使用情况。
-h # 以人类可读的显示显示内存的使用情况
-o # 不显示缓冲区调节列；
-s<间隔秒数> # 持续观察内存使用状况；
-t # 显示内存总和列；
-V # 显示版本信息。
```



## iftop命令

**iftop命令** 是一款实时流量监控工具，监控TCP/IP连接等，缺点就是无报表功能。必须以root身份才能运行。

系统不自带，需要从epel仓库下载。

- 语法

```shell
iftop [option]
```

- 选项

```
-i：指定监听的网络接口
-n：不进行DNS解析
-N：不将端口号解析成服务名
-B：以
-P
```

```shell
# 常用选项
[root@192 ~]# iftop -BPNn
TX:             cum:   29.5KB   peak:   11.3KB              rates:   11.3KB  7.38KB  7.38KB
RX:                    2.06KB            615B                         441B    528B    528B
TOTAL:                 31.6KB           11.7KB                       11.7KB  7.89KB  7.89KB
# TX：发送流量
# RX：接受流量
# TOTAL：总流量
# Cum：运行iftop到目前为止的总流量
# peak：流量峰值
# rates：分别代表过去2s、10s、40s的平均流量
```



## vmstat命令

**vmstat命令** 的含义为显示虚拟内存状态（“Viryual Memor Statics”），但是它可以报告关于进程、内存、I/O等系统整体运行状态。

- 语法

```shell
vmstat(选项)(参数)
```

- 选项

```
-a：显示活动内页；
-f：显示启动后创建的进程总数；
-m：显示slab信息；
-n：头信息仅显示一次；
-s：以表格方式显示事件计数器和内存状态；
-d：报告磁盘状态；
-p：显示指定的硬盘分区状态；
-S：输出信息的单位。
```



## mpstat命令

**mpstat命令** 主要用于多CPU环境下，它显示各个可用CPU的状态信息。这些信息存放在`/proc/stat`文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。

- 语法

```shell
mpstat [选项] [<间隔时间> [<次数>]]
```

- 选项

```
-P：指定CPU编号。
# -P 0表示第一个CPU
# -P ALL表示所有CPU
```

- 输出信息

```
%user：表示处理用户进程所使用CPU的百分比。
%nice：表示在用户级别处理经nice降级的程序所使用CPU的百分比。
%system：表示内核进程使用的CPU百分比。
%iowait：表示等待进行I/O所占用CPU时间百分比。
%irq：表示用于处理系统中断的CPU百分比。
%soft：表示用于处理软件中断的CPU百分比。
%steal：在管理程序为另一个虚拟处理器服务时，显示虚拟的一个或多个CPU在非自愿等待中花费的时间的百分比。
%guest：表示一个或多个CPU在运行虚拟处理器时所花费的时间百分比。
%gnice：表示一个或多个CPU在运行经nice降级后的虚拟处理器时所花费的时间百分比。
%idle：CPU的空闲时间百分比。
```



## iostat命令

**iostat命令** 被用于监视系统输入输出设备和CPU的使用情况。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。

- 语法

```shell
iostat [option] [interval[count]]
# 间隔时间：每次报告的间隔时间（秒）；
# 次数：显示报告的次数。
```

- 选项

```
-c：仅显示CPU使用情况；
-d：仅显示设备利用率；
-k：显示状态以千字节每秒为单位，而不使用块每秒；
-m：显示状态以兆字节每秒为单位；
-p：仅显示块设备和所有被使用的其他分区的状态；
-t：显示每个报告产生时的时间；
-V：显示版号并退出；
-x：显示扩展状态。
```

- 使用`-x`输出信息详细解释

| 标示     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| Device   | 监测设备名称                                                 |
| rrqm/s   | 每秒需要读取需求的数量                                       |
| wrqm/s   | 每秒需要写入需求的数量                                       |
| r/s      | 每秒实际读取需求的数量                                       |
| w/s      | 每秒实际写入需求的数量                                       |
| rsec/s   | 每秒读取区段的数量                                           |
| wsec/s   | 每秒写入区段的数量                                           |
| rkB/s    | 每秒实际读取的大小，单位为KB                                 |
| wkB/s    | 每秒实际写入的大小，单位为KB                                 |
| avgrq-sz | 需求的平均大小区段                                           |
| avgqu-sz | 需求的平均队列长度                                           |
| await    | 等待I/O平均的时间（milliseconds）                            |
| svctm    | I/O需求完成的平均时间                                        |
| %util    | 设备带宽的使用率，达到100%表示饱和，达到性能瓶颈，如果是支持处理并发请求的设备则不代表性能瓶颈。 |



## iotop命令

**iotop命令** 是一个用来监视磁盘I/O使用状况的top类工具。iotop具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息。Linux下的IO统计工具如iostat，nmon等大多数是只能统计到per设备的读写情况，如果你想知道每个进程是如何使用IO的就比较麻烦，使用iotop命令可以很方便的查看。

一般系统不自带，需要`yum install iotop`进行安装

- 语法

```shell
iotop [option]
```

- 选项

```
-o：只显示有io操作的进程
-b：批量显示，无交互，主要用作记录到文件。
-n NUM：显示NUM次，主要用于非交互式模式。
-d SEC：间隔SEC秒显示一次。
-p PID：监控的进程pid。
-u USER：监控的进程用户。
-t：显示时间
-k：设置单位为KB
```

- 快捷方式

```
左右箭头：改变排序方式，默认是按IO排序。
r：改变排序顺序。
o：只显示有IO输出的进程。
p：进程/线程的显示方式的切换。
a：显示累积使用量。
q：退出。
```

```bash
Total DISK READ :       0.00 B/s | Total DISK WRITE :      11.76 K/s
Actual DISK READ:       0.00 B/s | Actual DISK WRITE:      14.70 K/s
    TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND 
   1809 be/4 mysql       0.00 B/s    0.00 B/s  0.00 %  0.02 % mysql~=/usr
  53376 be/4 mysql       0.00 B/s    3.92 K/s  0.00 %  0.02 % mysql~=/usr
   1811 be/4 mysql       0.00 B/s    7.84 K/s  0.00 %  0.00 % mysql~=/usr
      1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % syste~ze 18
      2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]
      3 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_gp]
      4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_~r_gp]
      6 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kwor~hpri]
      9 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [mm_p~u_wq]
     10 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksof~qd/0]
     11 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_sched]
     12 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migr~on/0]
     
# Total DISK READ: 表示在采样期间，所有进程或线程从磁盘读取的数据的带宽。
# Total DISK WRITE: 表示在采样期间，所有进程或线程写入磁盘的数据的带宽。
# Actual DISK READ: 表示在采样期间，实际从磁盘读取的数据的带宽，不包括缓存的数据。
# Actual DISK WRITE: 表示在采样期间，实际写入磁盘的数据的带宽，不包括缓存的数据。
# TID: 表示线程的ID。
# PRIO: 表示线程运行的I/O优先级（类别/级别）。
# USER: 表示进程或线程的用户所有者。
# DISK READ: 表示在采样期间，该进程或线程从磁盘读取的数据的带宽。
# DISK WRITE: 表示在采样期间，该进程或线程写入磁盘的数据的带宽。
# SWAPIN: 表示该进程或线程在交换进入时花费的时间的百分比。
# IO: 表示该进程或线程在等待I/O操作时花费的时间的百分比。
# COMMAND: 表示该进程或线程的命令名称。
```



## sar命令

**sar命令** 是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。`sar`命令是sysstat软件包的一部分

`sar`会定期收集系统性能数据，并将其存储在指定的日志文件中。确保sysstat服务在系统启动时自动启用：

```bash
systemctl enable sysstat
systemctl start sysstat
```

- 语法

```shell
sar [option] [interval[count]]
```

- 选项

```markdown
-A: 显示所有的报告信息；
-b: 显示I/O速率；
-B: 显示换页状态；
-c: 显示进程创建活动；
-d: 显示每个块设备的状态；
-e: 设置显示报告的结束时间；
-f: 从指定文件提取报告；
-i: 设状态信息刷新的间隔时间；
-n: 报告网络统计信息。
  DEV：该命令用于显示每个网络接口的统计信息，包括接收和发送的数据包数、错误数、丢失的数据包数等。
  EDEV：该选项与 DEV 类似，但提供了更详细的错误统计信息，包括传输错误、碰撞等。
  NFSD：用于显示NFS服务器的网络统计信息。
  NFS：用于显示NFS客户端的网络统计信息。
  SOCK：用于显示套接字层的网络统计信息，包括套接字的创建、关闭等。
-P: 报告每个CPU的状态；
-r: 显示内存状态；
-u: 显示CPU利用率；
-v: 显示索引节点，文件和其他内核表的状态；
-w: 显示交换分区状态；
-x: 显示给定进程的状态。
```

```shell
sar -r
14时30分01秒 kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
14时40分01秒    562740   2181188   3235864     85.19      1060   1867220   1976132     19.58   1177584   1699416         8
14时50分01秒    562252   2181176   3236352     85.20      1060   1867692   1978672     19.61   1177584   1699748        16
15时00分01秒    561612   2181156   3236992     85.22      1060   1868300   1976136     19.58   1177576   1700340        12
15时10分01秒    561480   2181544   3237124     85.22      1060   1868812   1979260     19.62   1177584   1700820         8
平均时间:    562021   2181266   3236583     85.20      1060   1868006   1977550     19.60   1177582   1700081        11


# kbmemfree:表示系统空闲的物理内存量，以千字节（KB）为单位。这是系统当前未被使用的内存。
# kbavail:表示系统可用的物理内存量，以千字节（KB）为单位。这是系统中可用于分配给进程的内存，包括空闲的内存和页面缓存等。
# kbmemused:表示系统已使用的物理内存量，以千字节（KB）为单位。这是系统中已被进程或系统缓存使用的内存。
# %memused:表示系统已使用物理内存的百分比。计算公式为 (kbmemused / (kbmemused + kbmemfree)) * 100。
# kbbuffers:表示系统用于缓存的内存量，以千字节（KB）为单位。这包括用于缓冲 I/O 操作的内存。
# kbcached:表示系统用于缓存的页缓存内存量，以千字节（KB）为单位。这包括文件系统缓存的数据。
# kbcommit:表示系统当前已经分配但尚未使用的内存量，以千字节（KB）为单位。这包括为进程分配但尚未写入的内存和为文件系统缓存保留的内存。
# %commit:表示系统已经分配但尚未使用的内存在物理内存总量中的百分比。计算公式为 (kbcommit / (kbmemused + kbcommit)) * 100。
# kbactive:表示系统中当前活跃的内存量，以千字节（KB）为单位。这是系统当前正在使用的内存，包括被进程和内核使用的内存。
# kbinact:表示系统中当前非活跃的内存量，以千字节（KB）为单位。这是之前使用过但目前没有活跃进程使用的内存。
# kbdirty:表示系统中当前处于脏状态的内存量，以千字节（KB）为单位。脏内存是指已被修改但尚未被写回到磁盘的内存。
```
# 调式命令
## nsenter

nsenter 是一个可以用来进入到目标程序所在 Namespace 中运行命令的工具，一般常用于在宿主机上调试容器中运行的程序。

**命令安装**

nsenter 位于 util-linux 包中，一般常用的 Linux 发行版都已经默认安装。如果你的系统没有安装，可以使用以下命令进行安装：
```bash
$ yum install util-linux
```

**用途**

一个比较典型的用途就是进入容器的网络命名空间。通常容器为了轻量级，大多都是不包含较为基础网络管理调试工具，比如：ip、ping、telnet、ss、tcpdump 等命令，给调试容器内网络带来相当大的困扰。

nsenter 命令可以很方便的进入指定容器的网络命名空间，使用宿主机的命令调试容器网络。

除此以外，nsenter 还可以进入 mnt、uts、ipc、pid、user 等命名空间，以及指定根目录和工作目录。

**语法**

```
$ nsenter [options] [program [arguments]] 
options: 
-a, --all enter all namespaces of the target process by the default /proc/[pid]/ns/* namespace paths. 
-m, --mount[=<file>]：进入 mount 命令空间。如果指定了 file，则进入 file 的命名空间 
-u, --uts[=<file>]：进入 UTS 命名空间。如果指定了 file，则进入 file 的命名空间 
-i, --ipc[=<file>]：进入 System V IPC 命名空间。如果指定了 file，则进入 file 的命名空间 
-n, --net[=<file>]：进入 net 命名空间。如果指定了 file，则进入 file 的命名空间 
-p, --pid[=<file>：进入 pid 命名空间。如果指定了 file，则进入 file 的命名空间 
-U, --user[=<file>：进入 user 命名空间。如果指定了 file，则进入 file 的命名空间 
-t, --target <pid> # 指定被进入命名空间的目标进程的 pid 
-G, --setgid gid：设置运行程序的 GID 
-S, --setuid uid：设置运行程序的 UID 
-r, --root[=directory]：设置根目录 
-w, --wd[=directory]：设置工作目录
```
```bash
# 进入对应容器的网络空间，就可以直接使用宿主机的命令去排查网络
nsenter -t <pid> -n
```
# 其他命令

## set命令

在Shell脚本中，`set`命令用于修改脚本的行为和设置各种选项。

```bash
#!/bin/bash
set -e  # 一旦有退出码不为0则退出脚本，set +e取消设置
ll
ls
```

在Linux中，会被当做空字符串（empty string）处理。这意味着如果你尝试使用未定义的变量，它将被视为空字符串而不是导致错误。

```bash
#!/bin/bash
set +u  # 可以取消这个设置，一旦使用未定义变量则报错
echo $a
```



## ulimit命令

`ulimit`用于设置或显示用户级别的资源限制的命令。这些资源限制包括用户进程能够使用的虚拟内存、打开文件描述符的数量、CPU 时间等等。

- 选项

```bash
-a：显示当前所有系统资源使用限制
-n：显示或设置最多打开的文件数目
```

```bash
ulimit -n 65535 # 临时修改最大打开文件
echo '* - nofile 65535' >>  /etc/security/limits.conf
```



